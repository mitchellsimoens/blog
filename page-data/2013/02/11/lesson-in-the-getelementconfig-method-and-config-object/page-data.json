{"componentChunkName":"component---src-templates-blog-post-js","path":"/2013/02/11/lesson-in-the-getelementconfig-method-and-config-object/","webpackCompilationHash":"56543836aa9ef392dae0","result":{"data":{"site":{"siteMetadata":{"title":"Mitchell Simoens Blog","author":"Mitchell Simoens"}},"markdownRemark":{"id":"f593693f-43f7-5b52-a43b-0c0c9a623bb8","excerpt":"Recently I saw a blog post about creating a component to play YouTube videos in Sencha Touch 2. Of course the code worked but I could help but think there…","html":"<p>Recently I saw a <a href=\"http://training.figleaf.com/tutorials/senchacomplete/chapter2/lesson10/5.cfm\" title=\"blog post\" target=\"_blank\">blog post</a> about creating a component to play YouTube videos in Sencha Touch 2. Of course the code worked but I could help but think there should be a better way then to use the <code class=\"language-text\">Ext.String.format</code> method, of course I am not sure of the previous lessons as this is Chapter 2. This week I also have been running into people not understanding the <code class=\"language-text\">config</code> object and the getters/setters created for it so I felt like this YouTube component could be a great example to use. Also, last week someone asked me what the equivalent to the renderTpl property in Ext JS 4 was in Sencha Touch 2 so I decided to wrap the <code class=\"language-text\">getElementConfig</code> method in to this blog post as well. Hopefully this isn’t too much in one post, will take it as slow as I can.</p>\n<h2>Code Discovery</h2>\n<p>Let’s first look at how the blog post accomplished the YouTube video viewing. They create an extension of Ext.Component and create a string of an <code class=\"language-text\">&amp;#60;iframe&amp;#62;</code> to view the video. Couple things I didn’t like about this. First, I think using <code class=\"language-text\">Ext.String.format</code> isn’t the most ideal and flexible solution. Also the string generates a <code class=\"language-text\">&amp;#60;div&amp;#62;</code> wrapping the <code class=\"language-text\">&amp;#60;iframe&amp;#62;</code> so it can horizontally center the <code class=\"language-text\">&amp;#60;iframe&amp;#62;</code> but shouldn’t the parent container’s layout take care of this centering? The component also uses two width (<code class=\"language-text\">vWidth</code>) and height (<code class=\"language-text\">vHeight</code>) configs to set the size of the <code class=\"language-text\">&amp;#60;iframe&amp;#62;</code> but just like the centering, shouldn’t the parent container’s layout take care of the sizing? I think the <code class=\"language-text\">&amp;#60;iframe&amp;#62;</code> should have 100% height and width to take up the full size of the <code class=\"language-text\">Ext.Component</code>. Also, no need for the <code class=\"language-text\">styleHtmlContent</code> for this. So basically I just said they are doing it all wrong in my opinion, it works just there is a better way to do it. One thing I’ve learned, there is always going to be a better way to do things and many opinions of how it should be done.</p>\n<h2>New Code</h2>\n<p>I’m gonna throw out my code and then walk through why I did it and also learn how the <code class=\"language-text\">config</code> object and <code class=\"language-text\">getElementConfig</code> work.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Ux.YouTubePlayer&#39;, {\n    extend : &#39;Ext.Component&#39;,\n    xtype  : &#39;youtubeplayer&#39;,\n\n    config : {\n        cls     : &#39;youtube-player&#39;,\n        /**\n         * @cfg {String} url The base URL of the YouTube video.\n         */\n        url     : &#39;http://www.youtube.com/embed/&#39;,\n        /**\n         * @cfg {String} videoId The ID of the video.\n         */\n        videoId : null\n    },\n\n    getElementConfig : function() {\n        var tpl = this.callParent();\n\n        //The src will come from the updateVideoId method\n        tpl.children.push({\n            tag       : &#39;iframe&#39;,\n            //this is the property that will be used on the component\n            reference : &#39;videoIframe&#39;,\n            //would rather this be in CSS\n            style     : &#39;width:100%;height:100%;border:0;&#39;\n        });\n\n        return tpl;\n    },\n\n    /**\n     * This method will update the src attribute of the &amp;lt;iframe&amp;gt; when\n     * you execute setVideoId method.\n     */\n    updateVideoId : function(videoId) {\n        if (videoId) {\n            this.videoIframe.set({\n                src : this.getUrl() + videoId\n            });\n        }\n    }\n});</code></pre></div>\n<p>Few things I did here, instead of using the <code class=\"language-text\">alias</code> property I used the <code class=\"language-text\">xtype</code> property, this doesn’t do anything differently, just saves some code. I also got rid of the three configs (<code class=\"language-text\">vWidth&lt;span&gt;,</code>vHeight<code class=\"language-text\">and</code>styleHtmlContent<code class=\"language-text\">) for reasons discussed before and only kept the two important ones. Then I used the</code>getElementConfig<code class=\"language-text\">method and</code>updateVideoId<code class=\"language-text\">method to do the the logic instead of the</code>Ext.String.format`. But, we need to slow down and talk a little bit.</p>\n<h2>getElementConfig</h2>\n<p>In Ext JS 4, you would use the <code class=\"language-text\">renderTpl</code> property which uses <code class=\"language-text\">Ext.XTemplate</code> to setup the DOM elements for that component. In Sencha Touch 2 you cannot use the <code class=\"language-text\">renderTpl</code> property but of course we still need a way to setup the DOM elements. For this Sencha Touch 2 uses the <code class=\"language-text\">getElementConfig</code> method that returns a single or an array of element configs for <code class=\"language-text\">Ext.DomHelper</code>. At first glance people get scared away but it’s really simple. Let’s look at the <code class=\"language-text\">getElementConfig</code> for <code class=\"language-text\">Ext.Component</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">getElementConfig: function() {\n    return {\n        reference: &#39;element&#39;,\n        classList: [&#39;x-unsized&#39;],\n        children: this.getTemplate()\n    };\n}</code></pre></div>\n<p>This simple will return a single DOM element as that’s all <code class=\"language-text\">Ext.Component</code> needs. First property is the <code class=\"language-text\">reference</code> property which is just a string. This is the property on the component that this element will be cached as so this element can be accessed from <code class=\"language-text\">component.element</code>. The <code class=\"language-text\">classList</code> takes an array or string of the CSS classes to be applied to that element. The <code class=\"language-text\">children</code> property is an array of child elements which each of will look like above. The <code class=\"language-text\">getTemplate</code> method returns <code class=\"language-text\">this.template</code> so you could use the <code class=\"language-text\">template</code> property but you can get things off the class scope which can be very powerful and you can see the inheritance work if you extend a component that uses <code class=\"language-text\">this.template</code> without you breaking things. One thing that is not used here is what tag the element will be (div, span, etc) and the reason that is is the <code class=\"language-text\">tag</code> property defaults to ‘div’ so this will return a <code class=\"language-text\">&amp;#60;div&amp;#62;</code> element.</p>\n<p>So back to my YouTube component if we look at the <code class=\"language-text\">getElementConfig</code> method. First thing I do is get the object from the superclass (Ext.Component) which is the code snippet above. Then I added an iframe element to the children of what was returned from the superclass. This <code class=\"language-text\">&amp;#60;iframe&amp;#62;</code> will be cached to the <code class=\"language-text\">videoIframe</code> property on the component as specified in the <code class=\"language-text\">reference</code> property. We also give it some inline styles however I hate seeing inline styles. I much prefer using SASS (CSS) to specify styles like this but serving as an example and to not have an additional file for this blog post I just did an inline style. Since we have <code class=\"language-text\">cls</code> set to ‘youtube-player’ on this component we could use that to specify the styles.</p>\n<p>Ok, while writing this I think I can make it a little better and more elegant. Instead of pushing an element onto the children array in <code class=\"language-text\">getElementConfig</code> method after calling the superclass, let’s remove the <code class=\"language-text\">getElementConfig</code> method from the <code class=\"language-text\">Ux.YouTubePlayer</code> component and let’s use the <code class=\"language-text\">getTemplate</code> method. This is what the new code would look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Ux.YouTubePlayer&#39;, {\n    extend : &#39;Ext.Component&#39;,\n    xtype  : &#39;youtubeplayer&#39;,\n\n    config : {\n        cls     : &#39;youtube-player&#39;,\n        /**\n         * @cfg {String} url The base URL of the YouTube video.\n         */\n        url     : &#39;http://www.youtube.com/embed/&#39;,\n        /**\n         * @cfg {String} videoId The ID of the video.\n         */\n        videoId : null\n    },\n\n    getTemplate : function() {\n        return [\n            {\n                tag       : &#39;iframe&#39;,\n                //this is the property that will be used on the component\n                reference : &#39;videoIframe&#39;,\n                //would rather this be in CSS\n                style     : &#39;width:100%;height:100%;border:0;&#39;\n            }\n        ];\n    },\n\n    /**\n     * This method will update the src attribute of the &amp;lt;iframe&amp;gt; when\n     * you execute setVideoId method.\n     */\n    updateVideoId : function(videoId) {\n        if (videoId) {\n            this.videoIframe.set({\n                src : this.getUrl() + videoId\n            });\n        }\n    }\n});</code></pre></div>\n<p>I like that better. This goes to show that there are always better ways and talking through something can help quite a bit.</p>\n<h2>config Object</h2>\n<p>So we saw how we can create DOM elements but the other half of what I wanted to discuss is what the <code class=\"language-text\">config</code> object is and how it works. At first I thought I would hate this but I feel like I can’t live without it now, it’s magical! The <code class=\"language-text\">config</code> object is what holds all the configs, go figure! When you create a class and pass in a config object to that instantiation it gets applied on the <code class=\"language-text\">config</code> object you specify in the <code class=\"language-text\">Ext.define</code> call, the config object in <code class=\"language-text\">Ext.define</code> are like the default values for the configs. So instead of this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;MyClass&#39;, {\n    foo : null\n});</code></pre></div>\n<p>You would have</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;MyClass&#39;, {\n    config : {\n        foo : null\n    }\n});</code></pre></div>\n<p>So it nests the configs within an object now, what gives? Well, there is more to that <code class=\"language-text\">config</code> object. First, it generates a getter method. It takes the config, in this case ‘foo’, uppercases the first letter and prefixes ‘get’ so you get ‘getFoo’. This method simply returns the private <code class=\"language-text\">this._foo</code> property value. The other part is it generates a setter method which name is like the ‘getFoo’ but it’s ‘setFoo’. You probably think it just sets the value passed to the setFoo method to the <code class=\"language-text\">this._foo</code> private property, it does but it adds more flexibility. What I mean is it can look for and use applyFoo and updateFoo that you can (optional) specify in your <code class=\"language-text\">Ext.define</code> statement. The applyFoo, called an applier, can be used to transform the value passed into something else. For example, you can pass in a config object of a class and the applier method can take that config object and turn it into a class. The updateFoo method, called the updater, can be used to take action on the new value like adding listeners. So the workflow (in code) is like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">setFoo : function(value) {\n    var applier         = &#39;applyFoo&#39;,\n        updater         = &#39;updateFoo&#39;,\n        getter          = &#39;getFoo&#39;,\n        privateProperty = &#39;_foo&#39;,\n        oldValue        = this[getter]();\n\n    if (this[applier]) {\n        value = this[applier].call(this, value, oldValue);\n    }\n\n    if (typeof value != &#39;undefined&#39;) {\n        this.[privateProperty] = value;\n\n        if (this[updater]) {\n            this[updater].call(this, value, oldValue);\n        }\n    }\n}</code></pre></div>\n<p>This is very similar to the <code class=\"language-text\">generateSetter</code> method in <code class=\"language-text\">Ext.Class</code>. You can notice the workflow and that the applier and updater get both the value and the oldValue passed to it. So now the <code class=\"language-text\">MyClass</code> class can look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;MyClass&#39;, {\n    config : {\n        foo : null\n    },\n\n    applyFoo : function(newValue, oldValue) {\n        return Ext.factory(newValue, Ext.data.Store, oldValue);\n    },\n\n    updateFoo : function(newValue, oldValue) {\n        if (oldValue) {\n            oldValue.un(&#39;load&#39;, this.someFunction, this);\n        }\n\n        if (newValue) {\n            newValue.on(&#39;load&#39;, this.someFunction, this);\n        }\n    }\n});</code></pre></div>\n<p>So in the applyFoo we use the <code class=\"language-text\">Ext.factory</code> method to create an <code class=\"language-text\">Ext.data.Store</code> instance and return it, make sure you return something here. In the updateFoo, we removed a listener on the old value and added a listener on the new value. Can you see how awesome the config object is? You will see this pattern all over Sencha Touch 2 framework classes, it really does add quite a bit of power and flexibility.</p>\n<p>So back to the <code class=\"language-text\">Ux.YouTubePlayer</code> class that we are using for a real world example. We want to take advantage of any setVideoId execution to update the <code class=\"language-text\">&amp;#60;iframe&amp;#62;</code> with a new URL of the actual video. We expect the ID of the video so no need to specify an applier method as we don’t need to transform the value. However, we do need to take action on a new ID so we specify the updateVideoId method to change the src attribute on the <code class=\"language-text\">&amp;#60;iframe&amp;#62;</code> element.</p>\n<h2>Summary</h2>\n<p>I hope I didn’t cover too much in one blog post. You can see how to use the <code class=\"language-text\">getElementConfig</code> (and later the <code class=\"language-text\">getTemplate</code>) method works and also what the <code class=\"language-text\">config</code> object is and how it works with the getter/setter/applier/updater methods. Can you see how awesome this stuff is?!</p>","fields":{"slug":"/2013/02/11/lesson-in-the-getelementconfig-method-and-config-object/"},"frontmatter":{"title":"Lesson in the getElementConfig method and config object","date":"January 11, 2013"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2013/02/11/lesson-in-the-getelementconfig-method-and-config-object/","previous":{"fields":{"slug":"/2012/09/10/coding-style-vs-valid-javascript/"},"frontmatter":{"title":"Coding style vs valid Javascript"}},"next":{"fields":{"slug":"/2013/03/10/client-side-associations/"},"frontmatter":{"title":"Client side associations"}}}}}