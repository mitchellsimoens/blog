{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/2019/08/07/why-typescript-paths-failed-me/","webpackCompilationHash":"6c41cf4b3649ceebc887","result":{"data":{"site":{"siteMetadata":{"title":"Mitchell Simoens Blog","author":"Mitchell Simoens"}},"markdownRemark":{"id":"12594eef-a4f0-5bac-9c94-66aa10fbd94f","excerpt":"This year has really been the year of Typescript for me, I’ve been using is anywhere and everywhere I can. While there are some annoyances, I love it and I didn…","html":"<p>This year has really been the year of <a href=\"https://www.typescriptlang.org/\">Typescript</a> for me, I’ve been using is anywhere and everywhere I can. While there are some annoyances, I love it and I didn’t think I would. At the same time, I’ve been using React more and more and on larger projects, using <a href=\"https://webpack.js.org/configuration/resolve/#resolvealias\">aliases</a> that <a href=\"https://webpack.js.org/\">Webpack</a> provides has been great. When importing files, relative paths could get ugly but with aliases they can be relative to your <code class=\"language-text\">src</code> directory. But when working with Typescript, I didn’t have this feature… so I thought.</p>\n<h2>Enter paths</h2>\n<p>I don’t remember where I saw it first but I saw that TypeScript has a <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\">paths</a> feature. Ok, so this looked very similar to Webpack aliases and in development, it worked. Now instead of this code:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> Foo <span class=\"token keyword\">from</span> <span class=\"token string\">'../../../components/Foo'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>I could write:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> Foo <span class=\"token keyword\">from</span> <span class=\"token string\">'@/components/Foo'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>And all I had to do is have two things in my <code class=\"language-text\">compilerOptions</code> object in <code class=\"language-text\">tsconfig.json</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"baseUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\".\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"paths\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"@/*\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"./src/*\"</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This worked exactly like I wanted… in development.</p>\n<h2>First Issue</h2>\n<p>I call out that it worked in development because I actually published a module to <a href=\"https://www.npmjs.com/\">npm</a> and it simply didn’t work. I’d get an error like:</p>\n<blockquote>\n<p>Error: Cannot find module ’@/components/Foo’</p>\n</blockquote>\n<p>But wait… this code is compiled. Why is it trying to use the path I have in my <code class=\"language-text\">import</code> and not a relative path that TypeScript found? I feel like most people first using paths hit this and the reason is, it’s not meant to be analogous to Webpack’s alias. TypeScript paths are intended to be used to resolve type information used by various loaders, not resolve just anything. There are a couple GitHub issues for this, here is a link to the first explanation that made sense to me: <a href=\"https://github.com/Microsoft/TypeScript/issues/10866#issuecomment-246789510\">#10866</a>. There is lots of back and forth on these GitHub issues but it sounds like TypeScript isn’t going to change things to work the way we want in this case.</p>\n<h2>Solution</h2>\n<p>Not wanting to give up, I found a way around it. I found a <a href=\"https://www.npmjs.com/package/@zerollup/ts-transform-paths\">plugin</a> that during build, it will rewrite these paths to relative paths so CommonJS style requiring (like <a href=\"https://nodejs.org/en/\">Node.js</a> uses) will work. You can then edit your <code class=\"language-text\">tsconfig.json</code> to use this plugin:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"baseUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\".\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"paths\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"@/*\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"./src/*\"</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"plugins\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"transform\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"@zerollup/ts-transform-paths\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Run a build, test the compiled code and you’ll still see the same “Cannot find module” error. The reason for this is TypeScript <strong>doesn’t</strong> support plugins. So why did I say to use plugins? Instead of using TypeScript directly, you have to use a different project: <a href=\"https://github.com/cevek/ttypescript\">ttypescript</a>. So instead of using <code class=\"language-text\">tsc</code> command, you use <code class=\"language-text\">ttsc</code>. Now run a build and everything should work! Fantastic!</p>\n<p>Even though I hate that we have to use ttypescript and even though we are using something in a way it wasn’t intended, it works. At least for now. I do hope TypeScript supports plugins eventually. Ok, so it works… or wait, does it?</p>\n<h2>Second Issue</h2>\n<p>I felt like I was on an emotional rollercoaster. I published a version that used paths and it didn’t work. I worked around it using other libs and it worked… but then it didn’t. I moved a project to a <a href=\"https://en.wikipedia.org/wiki/Monorepo\">monorepo</a> using <a href=\"https://lerna.js.org/\">Lerna</a> (and <a href=\"https://yarnpkg.com/lang/en/docs/workspaces/\">yarn workspaces</a>). Each package had it’s own <code class=\"language-text\">tsconfig.json</code> that extended from a base <code class=\"language-text\">tsconfig.json</code> and I was using paths in the individual packages. However, when I wanted to import from another package in the monorepo, it couldn’t find the other package. The reason for this is each package had the <a href=\"https://docs.npmjs.com/files/package.json#main\"><code class=\"language-text\">main</code></a> field set to something like <code class=\"language-text\">lib/index.js</code> as when published, that’s what I needed. However, with TypeScript, that <code class=\"language-text\">lib/index.js</code> only exists when you build and during development, it’s not likely you’ll have that and even if you build in order to get it, as you develop and add/remove files, you’d have to build the package each time. I’m way too lazy for that and it didn’t feel like an efficient workflow for me and anyone else working on the project.</p>\n<p>So my solution, add TypeScript paths for each package that was going to be imported to target that package’s <code class=\"language-text\">src</code> directory in the same way my <code class=\"language-text\">@</code> path works. So an individual’s tsconfig.json would have this sort of thing:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"extends\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"../../tsconfig.json\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"baseUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\".\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"paths\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"@/*\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"./src/*\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"@somescope/core-pkg\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"../core-pkg/src/index.ts\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"@somescope/core-pkg/lib/*\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"../core-pkg/src/*\"</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Now, when one package had an import like:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-typescript line-numbers\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> Foo <span class=\"token keyword\">from</span> <span class=\"token string\">'@somescope/core-pkg/lib/Foo'</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>In development, it would then map to <code class=\"language-text\">../core-pkg/src/Foo</code> and work. However, once compiled, that plugin I was using would overwrite the path and have that relative path. Since each package gets published on it’s own, that wasn’t what I needed. I needed it to leave that import alone but write the <code class=\"language-text\">@</code> path so I wanted to have cake and eat it too. Luckily, that plugin I’m using has a way to exclude certain paths from what it processes. So my base <code class=\"language-text\">tsconfig.json</code> now has this:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compilerOptions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"plugins\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"transform\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"@zerollup/ts-transform-paths\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token property\">\"exclude\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n          <span class=\"token string\">\"@somescope/core-pkg\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token string\">\"@somescope/core-pkg/lib/*\"</span>\n        <span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>And now when it comes across an import matching that path, it simply leaves it alone. Great, this plugin is fantastic!</p>\n<h2>Recap</h2>\n<p>Let’s step back and recap what is going on. In development, I can import from the same package or another package using paths to load the TypeScript raw source without needing to build often or using the watch feature. When built, paths to the other packages are excluded and will remain the same after as it looks before, with the module import not a relative import. Great! We’re done… or are we?</p>\n<h2>Third Issue</h2>\n<p>Oh geez, I thought we were done except we weren’t. Something I noticed when I was building packages, TypeScript was also moving the other packages that we imported into the package’s <code class=\"language-text\">lib</code> directory. So once built, the <code class=\"language-text\">lib</code> directory looked like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">lib/\n  core-pkg/\n    src/\n      index.js\n      ...\n  my-pkg/\n    src/\n      index.js\n      ...</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Notice how the core package and the current package (my-pkg in this case) are there now? TypeScript will compile all the files you imported and move them into your build directory as it thinks you need it… you know, since we aren’t using paths how it was intended. So I had a <code class=\"language-text\">postbuild</code> script that I now delete that <code class=\"language-text\">core-pkg</code> directory (using <a href=\"https://www.npmjs.com/package/rifraf\">rifraf</a>) so the <code class=\"language-text\">lib</code> directory looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">lib/\n  my-pkg/\n    src/\n      index.js\n      ...</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>I could move all the <code class=\"language-text\">lib/my-pkg/src</code> files up to <code class=\"language-text\">lib</code> and delete the unnecessary <code class=\"language-text\">my-pkg/src</code> directories so things are more cleaned up but it works and I’m tired of fighting with this so I just kept it the way and updated the <code class=\"language-text\">main</code> field in <code class=\"language-text\">package.json</code> to be to that nested <code class=\"language-text\">lib/my-pkg/src/index.js</code>.</p>\n<h2>Fourth Issue</h2>\n<p>Oh good man why?! Yes, there is a fourth issue. When you are running code in development, TypeScript only loads a single <code class=\"language-text\">tsconfig.json</code> so if you are importing another package that is also using paths, TypeScript simply doesn’t know about the paths in that other package. So if both packages are using <code class=\"language-text\">@</code> as a path, it’ll try to load files imported by that other package into the package you are running in and it won’t find the proper file. And if you changed to a different path in that other package, say <code class=\"language-text\">^</code>, TypeScript simply won’t know what that it should try importing the file from that other package because it doesn’t load that package’s <code class=\"language-text\">tsconfig.json</code>.</p>\n<p>Ok, at this point I was done. I was done working around issues trying to get paths to work as something it wasn’t designed to. Could you get it to work? I’m not sure, I didn’t even look and I honestly do not care. The other package didn’t have a lot of files so going back to relative import paths worked and I just went with it.</p>\n<h2>Conclusion</h2>\n<p>After fighting with paths, I decided to not use it. I still have it used in one package that is the “main” package and it has a few files where paths has helped but the only reason I haven’t undone using paths is because I’d rather do other things than update 50 files and since I’m not going to use them going forward there just isn’t a payoff just yet. I’ll eventually undo using paths but you never know, maybe there will be official support. And like I said, you may be able to get something super elegant that works in development and production and it may be beautiful… I just lost motivation myself. If you’d like to see what project I am referring to, it’s the <a href=\"https://github.com/ModusCreateOrg/gimbal\">Gimbal</a> project at <a href=\"https://moduscreate.com/\">Modus Create</a>.</p>\n<p>I’m not saying paths are bad just if you’re gonna use them in a way they are not intended to be used, expect a bumpy road. And just because it works today doesn’t mean that TypeScript will have an update that will break ttypescript and you’ll have to wait till it gets updated to work. I doubt TypeScript wants to break things but they also are not obligated to keep it working. So use at your own risk!</p>","fields":{"readingTime":{"text":"8 min read"},"slug":"/2019/08/07/why-typescript-paths-failed-me/"},"frontmatter":{"title":"Why TypeScript Paths Failed Me","date":"August 07, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2019/08/07/why-typescript-paths-failed-me/","previous":{"fields":{"slug":"/2019/08/01/react-state-provider-hook/"},"frontmatter":{"title":"React State Provider with Hooks"}},"next":null}}}