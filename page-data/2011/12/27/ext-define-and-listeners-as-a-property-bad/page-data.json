{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/2011/12/27/ext-define-and-listeners-as-a-property-bad/","webpackCompilationHash":"8bfc8b7fa9836efccfc8","result":{"data":{"site":{"siteMetadata":{"title":"Mitchell Simoens Blog","author":"Mitchell Simoens"}},"markdownRemark":{"id":"8e19b123-1dca-5dd9-81ea-a6407cf24350","excerpt":"Note As of Ext JS 5 this blog is not true. We have made changes to Ext JS to handle the listeners as a property. In face, for MVVM, this is now the recommended…","html":"<p><strong>Note</strong> As of Ext JS 5 this blog is not true. We have made changes to Ext JS to handle the listeners as a property. In face, for MVVM, this is now the recommended practice. In Ext JS 6, a subclass cannot override the superclass’ listeners property.</p>\n<p>Recently I have noticed a lot of people on the forums using the <code class=\"language-text\">listeners</code>, in my opinion, the wrong way. Being event driven is a great tactic in application development, one that I often use. Template methods are great and have their uses but for things that are reacting to user interactions, events are going to be your best friend.</p>\n<p>Let’s look at a quick piece of code. Grids are used a lot and I often create an abstract class to handle all my grids as most of the stuff in grids can be abstracted out instead of having tons of duplicate code.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Ext.define(&#39;MyApp.view.grid.Abstract&#39;, {\n    extend : &#39;Ext.grid.Panel&#39;,\n    alias  : &#39;widget.myapp-grid-abstract&#39;,\n\n    initComponent : function() {\n        Ext.apply(this, {\n            dockedItems : this.buildDocks(),\n            selModel    : this.buildSelModel()\n        });\n\n        this.callParent(arguments);\n    },\n\n    buildDocks : function() {\n        var docks = Ext.Array.from(this.dockedItems);\n\n        docks.push({\n            xtype : &#39;toolbar&#39;,\n            dock  : &#39;top&#39;,\n            items : [\n                {\n                    text     : &#39;Delete&#39;,\n                    disabled : true,\n                    action   : &#39;delete&#39;\n                }\n            ]\n        });\n\n        return docks;\n    },\n\n    buildSelModel : function() {\n        return {\n            type : &#39;rowmodel&#39;,\n            mode : &#39;SIMPLE&#39;\n        };\n    }\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So you can see from this code (which usually isn’t the entire abstract class) that we are adding a top docked <code class=\"language-text\">Ext.Toolbar</code> with a disabled delete button and defining a selection model with <code class=\"language-text\">mode</code> set to ‘SIMPLE’. The delete button should enable and disable based on the number of rows selected, disabled if the number of rows selected is zero, otherwise enable it. Usually you would extend an abstract class but for this blog we will just instantiate the abstract class like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">new MyApp.view.grid.Abstract({\n    renderTo : Ext.getBody(),\n    width    : 400,\n    height   : 400,\n    title    : &#39;Test Grid&#39;,\n    columns  : [\n        {\n            header    : &#39;Row&#39;,\n            flex      : 1,\n            dataIndex : &#39;row&#39;\n        }\n    ],\n    store    : new Ext.data.Store({\n        fields : [&#39;row&#39;],\n        data   : [\n            { row : &#39;One&#39;   },\n            { row : &#39;Two&#39;   },\n            { row : &#39;Three&#39; },\n            { row : &#39;Four&#39;  },\n            { row : &#39;Five&#39;  }\n        ]\n    })\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So now we have a grid rendering as expected, time to handle the user interaction using the <code class=\"language-text\">selectionchange</code> event on the grid panel. This is where the problem lies. I have seen many developers add <code class=\"language-text\">listeners</code> like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Ext.define(&#39;MyApp.view.grid.Abstract&#39;, {\n    extend : &#39;Ext.grid.Panel&#39;,\n    alias  : &#39;widget.grid-abstract&#39;,\n\n    listeners : {\n        selectionchange : function(selModel, selected) {\n            var view = selModel.view,\n                grid = view.up(&#39;gridpanel&#39;),\n                btn  = grid.down(&#39;button[action=delete]&#39;);\n\n            btn.setDisabled(selected.length === 0);\n        }\n    },\n\n    initComponent : function() {\n        /**/\n    },\n\n    buildDocks : function() {\n        /**/\n    },\n\n    buildSelModel : function() {\n        /**/\n    }\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Notice the <code class=\"language-text\">listeners</code> property we just set on the class’ prototype. And this works but I have always been told just because it works doesn’t mean it’s right; to me, this is an invalid use of <code class=\"language-text\">listeners</code>. <code class=\"language-text\">listeners</code> is listed as a config option so what happens when you instantiate the class like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">new MyApp.view.grid.Abstract({\n    /**/\n    listeners : {\n        afterrender : function() {\n            console.log(&#39;my grid has rendered!&#39;);\n        }\n    }\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Now, try to enable that delete button by selecting a row. Did it work? The problem here is anything you pass in the config object will overwrite anything you set on the prototype in <code class=\"language-text\">Ext.define</code> so the <code class=\"language-text\">listeners</code> you set to listen for the <code class=\"language-text\">selectionchange</code> event is now overwritten by the <code class=\"language-text\">listeners</code> config object listening for the <code class=\"language-text\">afterrender</code> when we instantiated. You now easily broke your abstract class. This is why you should never use <code class=\"language-text\">listeners</code> when using <code class=\"language-text\">Ext.define</code>.</p>\n<p>So how do we go about to rectify this situation so that we can have our config listeners not overwrite our class listeners? The simple usage of <code class=\"language-text\">on()</code> will allow this, the only cavet is that we have to clean up the listener but that’s simple. Let’s delete the <code class=\"language-text\">listeners</code> from the <code class=\"language-text\">Ext.define</code> and put the <code class=\"language-text\">on()</code> usage into <code class=\"language-text\">initComponent</code> and use <code class=\"language-text\">un()</code> in <code class=\"language-text\">beforeDestroy</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Ext.define(&#39;MyApp.view.grid.Abstract&#39;, {\n    extend : &#39;Ext.grid.Panel&#39;,\n    alias  : &#39;widget.grid-abstract&#39;,\n\n    initComponent : function() {\n        var me = this;\n\n        Ext.apply(me, {\n            dockedItems : me.buildDocks(),\n            selModel    : me.buildSelModel()\n        });\n\n        me.callParent();\n\n        me.on(&#39;selectionchange&#39;, me.handleSelectionChange, me);\n    },\n\n    beforeDestroy: function() {\n        var me = this;\n\n        me.un(&#39;selectionchange&#39;, me.handleSelectionChange, me);\n\n        me.callParent(arguments);\n    },\n\n    buildDocks : function() {\n        /**/\n    },\n\n    buildSelModel : function() {\n        /**/\n    },\n\n    handleSelectionChange : function(selModel, selected) {\n        var view = selModel.view,\n            grid = view.up(&#39;gridpanel&#39;),\n            btn  = grid.down(&#39;button[action=delete]&#39;);\n\n        btn.setDisabled(selected.length === 0);\n    }\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Can you see where I used <code class=\"language-text\">on()</code> and <code class=\"language-text\">un()</code>? Now, when you render the grid, the listeners you placed in the config object that has an <code class=\"language-text\">afterrender</code> listener gets executed and if you select a row, the delete button will now enable.</p>\n<p>Awesome! Now we have a full functional abstract class that has event listeners that cannot be affected when instantiating a class.</p>","fields":{"slug":"/2011/12/27/ext-define-and-listeners-as-a-property-bad/"},"frontmatter":{"title":"Ext.define and listeners as a property... bad!","date":"December 27, 2011"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2011/12/27/ext-define-and-listeners-as-a-property-bad/","previous":{"fields":{"slug":"/2011/12/17/about-me/"},"frontmatter":{"title":"About me"}},"next":{"fields":{"slug":"/2012/02/04/actioncolumn-and-mvc/"},"frontmatter":{"title":"ActionColumn and MVC"}}}}}