{"componentChunkName":"component---src-templates-blog-post-js","path":"/2015/01/20/what-is-callparent-callsuper/","webpackCompilationHash":"89f576d1737dce10f556","result":{"data":{"site":{"siteMetadata":{"title":"Mitchell Simoens Blog","author":"Mitchell Simoens"}},"markdownRemark":{"id":"a1dc5f24-aab7-52b7-b8bf-47ae0b8c9f6f","excerpt":"One of the best things about Ext JS is it’s class system. Even though JavaScript doesn’t have a class system with inheritance, Ext JS utilizes different…","html":"<p>One of the best things about Ext JS is it’s class system. Even though JavaScript doesn’t have a class system with inheritance, Ext JS utilizes different JavaScript methods to create inheritance. This enables classes to extend one another to give power, flexibility and code reuse in a simple api otherwise not present in native JavaScript.</p>\n<h3>Introduction</h3>\n<p>First, let’s setup a couple classes <code class=\"language-text\">Bar</code> which extends <code class=\"language-text\">Foo</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Foo&#39;, {\n    someProp : 3,\n\n    someMethod : function() {\n        console.log(&#39;Foo&#39;, &#39;someMethod&#39;);\n    }\n});\n\nExt.define(&#39;Bar&#39;, {\n    extend : &#39;Foo&#39;,\n\n    anotherProp : &#39;test&#39;,\n    someProp    : 4\n});</code></pre></div>\n<p>If we look at this code, <code class=\"language-text\">Foo</code> is defined with <code class=\"language-text\">someProp</code> and <code class=\"language-text\">someMethod</code> members on that class. <code class=\"language-text\">Bar</code> is defined and extends <code class=\"language-text\">Foo</code>, adds an <code class=\"language-text\">anotherProp</code> member and overwrites <code class=\"language-text\">someProp</code> to have a different value than was defined on <code class=\"language-text\">Foo</code>. In this case, <code class=\"language-text\">Bar</code> will inherit the <code class=\"language-text\">someMethod</code> and therefore instances of <code class=\"language-text\">Bar</code> can execute the <code class=\"language-text\">someMethod</code> method. Let’s look at instantiation and execution:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var foo = new Foo();\n\nfoo.someProp === 3;\nfoo.someMethod(); //logs `Foo someMethod` to the console\n\nvar bar = new Bar();\n\nbar.anotherProp === &#39;test&#39;;\nbar.someProp === 4;\nbar.someMethod(); //logs &#39;Foo someMethod&#39; to the console</code></pre></div>\n<h3>Using <code class=\"language-text\">callParent</code></h3>\n<p>We have a need to add logic to <code class=\"language-text\">Bar</code>’s <code class=\"language-text\">someMethod</code> method but we still need to execute the <code class=\"language-text\">someMethod</code> that was inherited from <code class=\"language-text\">Foo</code>. If we simply add <code class=\"language-text\">someMethod</code> to <code class=\"language-text\">Bar</code> like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Bar&#39;, {\n    extend : &#39;Foo&#39;,\n\n    anotherProp : &#39;test&#39;,\n    someProp    : 4,\n\n    someMethod : function() {\n        console.log(&#39;Bar&#39;, &#39;someMethod&#39;);\n    }\n});</code></pre></div>\n<p>When we execute <code class=\"language-text\">bar.someMethod();</code> it will now only log out <code class=\"language-text\">Bar someMethod</code> and will not execute the <code class=\"language-text\">someMethod</code> method on the <code class=\"language-text\">Foo</code> class because we overrode the method. We can still call <code class=\"language-text\">Foo</code>’s <code class=\"language-text\">someMethod</code> by using the <code class=\"language-text\">callParent</code> method:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Bar&#39;, {\n    extend : &#39;Foo&#39;,\n\n    anotherProp : &#39;test&#39;,\n    someProp    : 4,\n\n    someMethod : function() {\n        console.log(&#39;Bar&#39;, &#39;someMethod&#39;);\n\n        this.callParent();\n    }\n});</code></pre></div>\n<p>Now when <code class=\"language-text\">bar.someMethod();</code> is executed, we will get <code class=\"language-text\">Bar someMethod</code> <strong>and</strong> <code class=\"language-text\">Foo someMethod</code> both logged to the console because <code class=\"language-text\">this.callParent();</code> calls the superclass’ (<code class=\"language-text\">Foo</code>) <code class=\"language-text\">someMethod</code> method.</p>\n<h4>Function arguments</h4>\n<p>Thus far, the <code class=\"language-text\">someMethod</code> method did not accept any arguments and therefore we didn’t need to deal with them and how to pass the arguments to the superclass’ method. Let’s modify <code class=\"language-text\">Foo</code> to handle a couple arguments:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Foo&#39;, {\n    someProp : 3,\n\n    someMethod : function(callback, scope) {\n        console.log(&#39;Foo&#39;, &#39;someMethod&#39;);\n\n        if (callback) {\n            callback.call(scope || this);\n        }\n    }\n});</code></pre></div>\n<p>We changed the signature of the <code class=\"language-text\">someMethod</code> method to accept <code class=\"language-text\">callback</code> and <code class=\"language-text\">scope</code> arguments which are optional but we need to now handle passing the arguments in our <code class=\"language-text\">someMethod</code> method in the <code class=\"language-text\">Bar</code> class in order to keep the behavior of the <code class=\"language-text\">Foo</code> <code class=\"language-text\">someMethod</code> method.</p>\n<p>We can do this two ways. The preferred way is to know what the arguments are and pass an array of the arguments to the <code class=\"language-text\">callParent</code> method call. This may take some educating yourself on what arguments are valid for that method by reading the source for the superclass and it’s ancestors. The other way is to use the special <code class=\"language-text\">arguments</code> keyword which holds the arguments for the current function block. Here are the two methods in action:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Bar&#39;, {\n    extend : &#39;Foo&#39;,\n\n    anotherProp : &#39;test&#39;,\n    someProp    : 4,\n\n    someMethod : function(callback, scope) {\n        console.log(&#39;Bar&#39;, &#39;someMethod&#39;);\n\n        this.callParent([callback, scope]);\n    }\n});</code></pre></div>\n<p>or with the <code class=\"language-text\">arguments</code> keyword:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Bar&#39;, {\n    extend : &#39;Foo&#39;,\n\n    anotherProp : &#39;test&#39;,\n    someProp    : 4,\n\n    someMethod : function(callback, scope) {\n        console.log(&#39;Bar&#39;, &#39;someMethod&#39;);\n\n        this.callParent(arguments);\n    }\n});</code></pre></div>\n<p>I personally always try to know what arguments are possible and use the first method. Documentation can really help here or simply reading the source from that class’ ancestors. If you know a method will never have any arguments, <code class=\"language-text\">initComponent</code> in <code class=\"language-text\">Ext.Component</code> for example, then you can simply execute <code class=\"language-text\">callParent</code> without passing any parameters: <code class=\"language-text\">this.callParent();</code></p>\n<h3>Using <code class=\"language-text\">callSuper</code></h3>\n<p>Like <code class=\"language-text\">callParent</code>, <code class=\"language-text\">callSuper</code> allows you to call an ancestor method when overwriting one. There are two differences:</p>\n<ul>\n<li><code class=\"language-text\">callSuper</code> is only usable within an override</li>\n<li>While <code class=\"language-text\">callParent</code> calls the inherited method, <code class=\"language-text\">callSuper</code> will skip the directly inherited method and call the next level’s method.</li>\n</ul>\n<p>Let’s create an override to <code class=\"language-text\">Bar</code> to explore how to use the <code class=\"language-text\">callSuper</code> method:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Override.Bar&#39;, {\n    override : &#39;Bar&#39;,\n\n    someMethod : function(callback, scope) {\n        console.log(&#39;Override.Bar&#39;, &#39;someMethod&#39;);\n    }\n});</code></pre></div>\n<p>In this example, we are globally overwriting the <code class=\"language-text\">someMethod</code> method on <code class=\"language-text\">Bar</code>. When we execute <code class=\"language-text\">bar.someMethod();</code> we will only see the <code class=\"language-text\">Override.Bar someMethod</code>. Our need to is not call the <code class=\"language-text\">someMethod</code> method on the <code class=\"language-text\">Bar</code> class but skip it and call the method on the <code class=\"language-text\">Foo</code> class. We can do this with <code class=\"language-text\">callSuper</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Override.Bar&#39;, {\n    override : &#39;Bar&#39;,\n\n    someMethod : function(callback, scope) {\n        console.log(&#39;Override.Bar&#39;, &#39;someMethod&#39;);\n\n        this.callSuper([callback, scope]);\n    }\n});</code></pre></div>\n<p>Now when <code class=\"language-text\">bar.someMethod();</code> is executed, we will get both <code class=\"language-text\">Override.Bar someMethod</code> and <code class=\"language-text\">Foo someMethod</code> logged to the console. Also note that passing arguments works exactly like it did with <code class=\"language-text\">callParent</code>.</p>\n<h3>Handling returning something</h3>\n<p>What if the <code class=\"language-text\">someMethod</code> in the <code class=\"language-text\">Foo</code> class returned something? How do we handle this with <code class=\"language-text\">callParent</code> and <code class=\"language-text\">callSuper</code>? Well, it’s actually quite simple. First, let’s look at the changes to <code class=\"language-text\">Foo</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Foo&#39;, {\n    someProp : 3,\n\n    someMethod : function(callback, scope) {\n        console.log(&#39;Foo&#39;, &#39;someMethod&#39;);\n\n        if (callback) {\n            callback.call(scope || this);\n        }\n\n        return this;\n    }\n});</code></pre></div>\n<p>Now <code class=\"language-text\">someMethod</code> is chainable as it returns <code class=\"language-text\">this</code> which is likely the <code class=\"language-text\">Foo</code> class. Now we need to handle this in the <code class=\"language-text\">Bar</code> class where we use <code class=\"language-text\">callParent</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Bar&#39;, {\n    extend : &#39;Foo&#39;,\n\n    anotherProp : &#39;test&#39;,\n    someProp    : 4,\n\n    someMethod : function(callback, scope) {\n        console.log(&#39;Bar&#39;, &#39;someMethod&#39;);\n\n        return this.callParent([callback, scope]);\n    }\n});</code></pre></div>\n<p>All I did here was add <code class=\"language-text\">return</code>, <code class=\"language-text\">callParent</code> is just a placeholder for calling the superclass’ method and therefore will return whatever that method returns. The same goes for when <code class=\"language-text\">callSuper</code> is used:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Override.Bar&#39;, {\n    override : &#39;Bar&#39;,\n\n    someMethod : function(callback, scope) {\n        console.log(&#39;Override.Bar&#39;, &#39;someMethod&#39;);\n\n        return this.callSuper([callback, scope]);\n    }\n});</code></pre></div>\n<p>What if you need to do something with what is returned from <code class=\"language-text\">callParent</code> or <code class=\"language-text\">callSuper</code>? Just cache the execution to a local variable and return that variable. Once again this is exactly the same between <code class=\"language-text\">callParent</code> and <code class=\"language-text\">callSuper</code> so I will only show one:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Override.Bar&#39;, {\n    override : &#39;Bar&#39;,\n\n    someMethod : function(callback, scope) {\n        console.log(&#39;Override.Bar&#39;, &#39;someMethod&#39;);\n\n        var ret = this.callSuper([callback, scope]);\n\n        console.log(&#39;Override.Bar&#39;, ret.someProp);\n\n        return ret;\n    }\n});</code></pre></div>\n<p>With all the classes and the override in place, when <code class=\"language-text\">bar.someMethod();</code> is executed it will return <code class=\"language-text\">this</code> (which will be the instance of Bar) but will now log these in this order: <code class=\"language-text\">Override.Bar someMethod</code>, <code class=\"language-text\">Foo someMethod</code> and <code class=\"language-text\">Override.Bar 4</code>. Couple things to note here, since we used <code class=\"language-text\">callSuper</code> in the override, the <code class=\"language-text\">someMethod</code> defined on the <code class=\"language-text\">Bar</code> class was not executed as it was skipped due to using <code class=\"language-text\">callSuper</code> and the scope is the instance that was created which is that of the <code class=\"language-text\">Bar</code> class (since we used <code class=\"language-text\">var bar = new Bar();</code> in the beginning) which is why <code class=\"language-text\">ret.someProp</code> returns <code class=\"language-text\">4</code> <strong>not</strong> <code class=\"language-text\">3</code>.</p>","fields":{"slug":"/2015/01/20/what-is-callparent-callsuper/"},"frontmatter":{"title":"What is callParent and callSuper?","date":"January 20, 2015"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2015/01/20/what-is-callparent-callsuper/","previous":{"fields":{"slug":"/2015/01/09/documentation-friday/"},"frontmatter":{"title":"Documentation Friday!"}},"next":{"fields":{"slug":"/2015/01/20/overriding-methods-safely/"},"frontmatter":{"title":"Overriding methods safely"}}}}}