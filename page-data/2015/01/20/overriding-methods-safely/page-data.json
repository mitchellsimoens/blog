{"componentChunkName":"component---src-templates-blog-post-js","path":"/2015/01/20/overriding-methods-safely/","webpackCompilationHash":"02bb8f8c0b363ef91a23","result":{"data":{"site":{"siteMetadata":{"title":"Mitchell Simoens Blog","author":"Mitchell Simoens"}},"markdownRemark":{"id":"d47b4585-3a41-588c-85a1-6a977eaa4789","excerpt":"In the article Abstract vs Override, I talked about how to use overrides in an application to globally change Ext JS to work for your application. I was…","html":"<p>In the article <a href=\"https://sencha.guru/2014/12/04/abstract-vs-override/\">Abstract vs Override</a>, I talked about how to use overrides in an application to globally change <a href=\"http://www.sencha.com/products/extjs\">Ext JS</a> to work for your application. I was recently asked for the best way to override a method by a colleague and that made me think that talking about some techniques may help. It’s not enough to know how to do it, but to know some real-world techniques is helpful.</p>\n<h3>Introduction</h3>\n<p>There are a couple use cases for overriding, most popular is to globally change the behavior or to fix a bug. If you’re not familiar with other programming languages that have a class structure with inheritance, the best way to think of a class structure is a tree struture or like a file system. A class (called a subclass) can extend another class (called a superclass) where the subclass will inherit all members (configs, properties and methods) from the superclass. Overriding allows you to hook into any of these classes to override that member.</p>\n<h3><code class=\"language-text\">Ext.define</code> vs <code class=\"language-text\">Ext.override</code></h3>\n<p>First, let’s look at the anatomy of how to override. In previous Ext JS versions you could use <code class=\"language-text\">Ext.override</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.override(Ext.Component, {\n    foo : &#39;bar&#39;\n});</code></pre></div>\n<p>Or the class has a static <code class=\"language-text\">override</code> method also:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.Component.override({\n    foo : &#39;bar&#39;\n});</code></pre></div>\n<p>And while this still works, it’s better to use <code class=\"language-text\">Ext.define</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Override.Component&#39;, {\n    override : &#39;Ext.Component&#39;,\n\n    foo : &#39;bar&#39;\n});</code></pre></div>\n<p>While this is more characters, it comes with two benefits:</p>\n<ul>\n<li>Similar API to using <code class=\"language-text\">Ext.define</code> to extend a class.</li>\n<li>Override can be dynamically loaded and required using Cmd or plain <code class=\"language-text\">Ext.Loader</code> and then can also be organized in a file system.</li>\n</ul>\n<p>It’s recommended to use <code class=\"language-text\">Ext.define</code> and defining one override per file. Cmd has the ability to auto-include overrides for you and include them when you build an application.</p>\n<h3>Overriding Properties</h3>\n<p>One of the basic and simplest usages of an override is overriding properties. Looking at the previous code snippets, we actually see how to override properties. Of course in that snippet the override didn’t actually override anything, it added a property onto <code class=\"language-text\">Ext.Component</code>. Looking at the API documentation for <code class=\"language-text\">Ext.Component</code> we can see many properties/configs such as the <code class=\"language-text\">hideMode</code> config which will control how the component is hidden. By default it’s value is <code class=\"language-text\">display</code> which will hide the component but using the CSS <code class=\"language-text\">display:none</code> style which will cause the space taken up by the component not to be reserved. If we change <code class=\"language-text\">hideMode</code> to <code class=\"language-text\">visibility</code> then when the component is hidden the space is still reserved for the component it’s just not visible due to now using the CSS <code class=\"language-text\">visibility:hidden</code> style. We can override this to affect any <code class=\"language-text\">Ext.Component</code> or subclass like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Override.Component&#39;, {\n    override : &#39;Ext.Component&#39;,\n\n    hideMode : &#39;visibility&#39;\n});</code></pre></div>\n<p>Now when we hide a component, the space where the component was is still reserved for the component, you just cannot visually see the component anymore. Of course beware, this will override every single <code class=\"language-text\">Ext.Component</code> and subclass.</p>\n<h3>Overriding Methods</h3>\n<p>Let’s say we have a <code class=\"language-text\">Foo</code> class that has a <code class=\"language-text\">someMethod</code> method defined on it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Foo&#39;, {\n    someMethod : function() {\n        console.log(&#39;Foo&#39;, &#39;someMethod&#39;);\n    }\n});</code></pre></div>\n<p>If we instantiate <code class=\"language-text\">Foo</code> and execute the <code class=\"language-text\">someMethod</code>, we will get <code class=\"language-text\">Foo someMethod</code> logged out to the console.</p>\n<p>We find that there is a bug in it but we don’t have control over the <code class=\"language-text\">Foo</code> class, say it’s in some third party code where we cannot edit the source so we need to override the <code class=\"language-text\">someMethod</code> method. We can do this just like how we overrode a property:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Override.Foo&#39;, {\n    override : &#39;Foo&#39;,\n\n    someMethod : function() {\n        console.log(&#39;Override.Foo&#39;, &#39;someMethod&#39;);\n    }\n});</code></pre></div>\n<p>Now if we instantiate <code class=\"language-text\">Foo</code> and execute <code class=\"language-text\">someMethod</code>, we will only get <code class=\"language-text\">Override.Foo someMethod</code> logged out to the console. We will <strong>not</strong> see the <code class=\"language-text\">Foo someMethod</code> logged because we overrode the method; it’s like the <code class=\"language-text\">someMethod</code> defined in the <code class=\"language-text\">Foo</code> class never existed.</p>\n<h4>Using <code class=\"language-text\">callParent</code></h4>\n<p>In the last override, we overrode the <code class=\"language-text\">someMethod</code> method on the <code class=\"language-text\">Foo</code> class to fix a bug. It’s possible that the fix to the bug still needs to call the method that is being overridden, maybe we need to still have the <code class=\"language-text\">Foo someMethod</code> logged out. This is where the <code class=\"language-text\">callParent</code> method comes in, it tracks what method was overridden to make it still executable:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Override.Foo&#39;, {\n    override : &#39;Foo&#39;,\n\n    someMethod : function() {\n        console.log(&#39;Override.Foo&#39;, &#39;someMethod&#39;);\n\n        this.callParent();\n    }\n});</code></pre></div>\n<p>So now if we instantiate <code class=\"language-text\">Foo</code> and execute <code class=\"language-text\">someMethod</code> we will get <code class=\"language-text\">Override.Foo someMethod</code> logged to the console but we will also get <code class=\"language-text\">Foo someMethod</code> logged out thanks to the <code class=\"language-text\">this.callParent();</code> call.</p>\n<h4>Using <code class=\"language-text\">callSuper</code></h4>\n<p>Ext JS has a large class system where there are multiple levels of inheritance. There may be a time when one class extends another class and the subclass calls it’s superclass’ method. Say we need to override the subclass’ method to fix a bug but instead of calling the overridden method using <code class=\"language-text\">callParent</code> we need to skip that method and call the superclass’ method. This is where <code class=\"language-text\">callSuper</code> comes in handy. First, let’s look at a <code class=\"language-text\">Bar</code> class that extends <code class=\"language-text\">Foo</code> and uses <code class=\"language-text\">callParent</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Bar&#39;, {\n    extend : &#39;Foo&#39;,\n\n    someMethod : function() {\n        console.log(&#39;Bar&#39;, &#39;someMethod&#39;);\n\n        this.callParent();\n    }\n});</code></pre></div>\n<p>If we instantiate <code class=\"language-text\">Bar</code> and execute <code class=\"language-text\">someMethod</code> we will get all <code class=\"language-text\">Bar someMethod</code>, <code class=\"language-text\">Override.Foo someMethod</code> and <code class=\"language-text\">Foo someMethod</code> logged out to the console. Remember, we still have <code class=\"language-text\">Override.Foo</code> override in place.</p>\n<p>Let’s see what <code class=\"language-text\">callSuper</code> does when we override the <code class=\"language-text\">someMethod</code> on <code class=\"language-text\">Bar</code> with this override:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Override.Bar&#39;, {\n    override : &#39;Bar&#39;,\n\n    someMethod : function() {\n        console.log(&#39;Override.Bar&#39;, &#39;someMethod&#39;);\n\n        this.callSuper();\n    }\n});</code></pre></div>\n<p>Now if we instantiate <code class=\"language-text\">Bar</code> and execute <code class=\"language-text\">someMethod</code> we should <strong>not</strong> see the <code class=\"language-text\">Bar someMethod</code> logged to the console because <code class=\"language-text\">this.callSuper();</code> should skip that method. And sure enough, we see <code class=\"language-text\">Override.Bar someMethod</code>, <code class=\"language-text\">Override.Foo someMethod</code> and <code class=\"language-text\">Foo someMethod</code> logged to the console.</p>\n<h4>Difference of <code class=\"language-text\">callParent</code> vs <code class=\"language-text\">callSuper</code></h4>\n<p>The difference between <code class=\"language-text\">callParent</code> and <code class=\"language-text\">callSuper</code> is what method ends up being executed. <code class=\"language-text\">callParent</code> will always call the method being overridden where <code class=\"language-text\">callSuper</code> will skip the method being overridden and call a superclass’ method.</p>\n<h3>Overriding Singletons</h3>\n<p>I’m a big fan of having a singleton class to manage certain things like application configs. Let’s say we have something like this for a singleton (simplified than what I have):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;MyApp.Config&#39;, {\n    singleton : true,\n\n    config : {\n        configs : null\n    },\n\n    constructor : function() {\n        this.initConfig();\n        this.callParent();\n    },\n\n    get : function(key) {\n        return this.getConfigs()[key];\n    }\n});</code></pre></div>\n<p>Without our code we can do things like <code class=\"language-text\">MyApp.Config.get(&#39;foo&#39;)</code>. But there in an issue with the <code class=\"language-text\">get</code> method, what if <code class=\"language-text\">this.getConfigs()</code> returns a non-Object such as the <code class=\"language-text\">get</code> method was executed before an Xhr call finishes and therefore <code class=\"language-text\">this.getConfigs()</code> will return <code class=\"language-text\">null</code>. We need to handle this case.</p>\n<p>For demonstration purposes, say we cannot edit the source for <code class=\"language-text\">MyApp.Config</code> and therefore we need to use an override. Of course, if you have control over the file, edit the source instead of creating an override.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Override.Config&#39;, {\n    override : &#39;MyApp.Config&#39;,\n\n    get : function(key) {\n        var configs = this.getConfigs();\n\n        return configs ? configs[key] : null;\n    }\n});</code></pre></div>\n<p>Now when we use <code class=\"language-text\">MyApp.Config.get(&#39;foo&#39;)</code> we are protected from whether or not there are configs. <code class=\"language-text\">callParent</code> and <code class=\"language-text\">callSuper</code> work just like overrides on class definitions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.define(&#39;Override.Config&#39;, {\n    override : &#39;MyApp.Config&#39;,\n\n    get : function(key) {\n        return this.getConfigs() ?\n            this.callParent([key]) :\n            null;\n    }\n});</code></pre></div>\n<p>This override will execute <code class=\"language-text\">this.callParent([key])</code> if <code class=\"language-text\">this.getConfigs()</code> returns truthy else will return <code class=\"language-text\">null</code>.</p>\n<h3>More Reading</h3>\n<p>I also split off some more reading about <code class=\"language-text\">callParent</code> and <code class=\"language-text\">callSuper</code> in another blog: <a href=\"https://sencha.guru/2015/01/20/what-is-callparent-callsuper/\">What is callParent and callSuper</a>.</p>","fields":{"slug":"/2015/01/20/overriding-methods-safely/"},"frontmatter":{"title":"Overriding methods safely","date":"January 20, 2015"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2015/01/20/overriding-methods-safely/","previous":{"fields":{"slug":"/2015/01/20/what-is-callparent-callsuper/"},"frontmatter":{"title":"What is callParent and callSuper?"}},"next":{"fields":{"slug":"/2015/02/11/project-managing-personal-finances/"},"frontmatter":{"title":"Project Managing Personal Finances"}}}}}