{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/2015/07/03/saving-hierarchal-data-in-mysql-with-node-js/","webpackCompilationHash":"c30757310a50aa570ced","result":{"data":{"site":{"siteMetadata":{"title":"Mitchell Simoens Blog","author":"Mitchell Simoens"}},"markdownRemark":{"id":"c916d515-343c-513e-9131-c35adb4bed51","excerpt":"I have a need that I’ve solved before but have never been happy with my solutions. So today I decided to give it another go. It’s taking hierarchical data (tree…","html":"<p>I have a need that I’ve solved before but have never been happy with my solutions. So today I decided to give it another go. It’s taking hierarchical data (tree data) and saving it into a MySQL database. Searching around, there wasn’t a solution that I liked. Some were SQL only but didn’t seem to fit how I am presented with data. Some were using server-side frameworks, however, I’m not using any.</p>\n<h3>Server Overview</h3>\n<p>When I said I’m not using any server-side framework it’s not 100% true. I am using <a href=\"http://expressjs.com/\">ExpressJS</a> which is a framework but not in the sense of a framework that manages data; it’s much more of a framework around creating a server. There isn’t an MVC aspect of it. I’ve built my own framework to be custom to the projects I own within <a href=\"https://www.sencha.com/\">Sencha</a> and I name it node-sencha (not on npm currently) and reflects the API of Ext JS. So I basically have a pretty bare bones setup that I’ve built on top. For communication with my MySQL databases I use the <a href=\"https://www.npmjs.com/package/mysql\">mysql</a> module. I feel using ExpressJS and mysql module is a very common setup so I won’t go into it more than just that. Technically, the mysql module isn’t required for this but it’s serving as an important piece on how I construct the SQL queries.</p>\n<h3>Pre-Thoughts</h3>\n<p>I’ve seen some solutions that had some pros and cons and some of the cons were that it was very expensive. I control both the client (which is Ext JS) and the server so I can do things any way I want (some would be jealous, some would be scared :) ). Starting off I decided to go ahead and send the full tree when saving regardless of if the nodes had been changed or not. This is great for its total ease but something I’ll definitely have to revisit at a later time to better the performance and not have unneeded queries.</p>\n<p>For saving tree data you need to deal with creating, updating and deleting nodes. Since I’m going to have the full tree, this will be easy to do all three actions in a single MySQL transaction. The only hard part is dealing with the parent-to-child relationship where the parent may or may not already exist.</p>\n<h3>Ext JS</h3>\n<p>When using <code class=\"language-text\">Ext.data.TreeStore</code> and the related classes, Ext JS will create IDs for each node that you create on the client. I can use this to determine if the node passed to the server is a phantom (does not exist in the db) or not. Ext JS does set the <code class=\"language-text\">phantom</code> property on the model but using the ID is a single way to handle create vs update. The data I send back to the server is like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">[\n    {\n        &quot;id&quot;       : &quot;Model-1&quot;,\n        &quot;text&quot;     : &quot;Parent 1.1&quot;,\n        &quot;children&quot; : [\n            {\n                &quot;id&quot;   : &quot;Model-3&quot;,\n                &quot;text&quot; : &quot;Leaf 1.1&quot;\n            }\n        ]\n    },\n    {\n        &quot;id&quot;       : &quot;Model-2&quot;,\n        &quot;text&quot;     : &quot;Parent 1.2&quot;,\n        &quot;children&quot; : [\n            {\n                &quot;id&quot;   : &quot;Model-4&quot;,\n                &quot;text&quot; : &quot;Leaf 1.2&quot;\n            }\n        ]\n    }\n]</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Each node is an Object in the JSON and each node can have a <code class=\"language-text\">children</code> property and can nest as many children. If we look at the <code class=\"language-text\">id</code> property, it’s in a format that has the Ext JS model’s class name and an auto-incremented number joined by a hyphen. This is Ext JS creating a client side ID for a phantom record. In the database, I expect only integers for IDs so if it’s a string and has a hyphen, chances are it’s a phantom. Right there is how I determine if the node needs to be created or updated. In the database I also have a <code class=\"language-text\">parentid</code> field in the table so that a child can relate to its parent. You can see there is no <code class=\"language-text\">parentid</code> because on the server I can just get it from when I iterate through things. The trick there is to determine if the parent is phantom or not and getting the ID when the parent is being created.</p>\n<h3>Server Stuff</h3>\n<p>On the server, I pass the data to a <code class=\"language-text\">Tree</code> function and execute the <code class=\"language-text\">save</code> method on it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">var Tree = require(&#39;./Tree&#39;);\n\nnew Tree(data).save(function() { /* */ });</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>In the <code class=\"language-text\">Tree.js</code> file, I start with code like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">var mysql       = require(&#39;mysql&#39;),\n    phantomIdRe = /-/g;\n\nfunction Tree(data) {\n    this.data    = data;\n    this.sqls    = [];\n    this.inserts = [];\n    this.vars    = {};\n    this.realIds = [];\n\n    return this;\n}\n\nTree.prototype.isArray = function(value) {\n    return Object.prototype.toString.call(value) === &#39;[object Array]&#39;;\n};\n\nTree.prototype.isIdPhantom = function(id) {\n    return typeof id === &#39;string&#39; &amp;&amp; id.indexOf(&#39;-&#39;) &gt; -1;\n};\n\nTree.prototype.parsePhantomId = function(id) {\n    return id.replace(phantomIdRe, &#39;_&#39;);\n};\n\nTree.prototype.save = function(callback) {\n    var data    = this.data,\n        sqls    = this.sqls,\n        inserts = this.inserts,\n        tree;\n\n    this.parseChildren(data);\n\n    if (this.realIds &amp;&amp; this.realIds.length) {\n        //delete any nodes that were not passed\n        sqls.unshift(&#39;DELETE FROM my_table WHERE id NOT IN(?);&#39;);\n        inserts.unshift(this.realIds);\n    }\n\n    //execute the sqls\n    console.log(mysql.format(sqls.join(&#39;&#39;), inserts));\n\n    callback();\n};\n\nmodule.exports = Tree;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Nothing special so far, the <code class=\"language-text\">isIdPhantom</code> function will do the checking if the id has a hyphen. The <code class=\"language-text\">parsePhantomId</code> will replace hyphens with underscores, more about that later. The <code class=\"language-text\">save</code> method is what really kicks things off. It first executes the <code class=\"language-text\">parseChildren</code> method which allows for recursion:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Tree.prototype.parseChildren = function(children, parent) {\n    if (!this.isArray(children)) {\n        children = children.children;\n    }\n\n    var i        = 0,\n        length   = children.length,\n        parentid = parent &amp;&amp; parent.id,\n        node;\n\n    if (length) {\n        for (; i &lt; length; i++) {\n            node = children[i];\n\n            this.parseNode(node, parentid);\n\n            if (node.children) {\n                this.parseChildren(node.children, node);\n            }\n        }\n    }\n};</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The important part here is it’ll call <code class=\"language-text\">parseChildren</code> if the current node has any children but also the new <code class=\"language-text\">parseNode</code> method which does the real “magic”. Hope I’m not loosing you yet, here’s <code class=\"language-text\">parseNode</code> and it’s a little long:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Tree.prototype.parseNode = function(node, parentid) {\n    var sqls    = this.sqls,\n        inserts = this.inserts,\n        vars    = this.vars,\n        id      = node.id,\n        parentVar;\n\n    if (parentid) {\n        if (this.isIdPhantom(parentid)) {\n            parentVar = vars[parentid];\n\n            if (!parentVar) {\n                //no variable means it wasn&#39;t a phantom\n                parentVar = &#39;?&#39;;\n                inserts.push(parentid);\n            }\n        } else {\n            //wasn&#39;t a phantom\n            parentVar = &#39;?&#39;;\n            inserts.push(parentid);\n        }\n    } else {\n        //is a root child node\n        parentVar = &#39;?&#39;;\n        inserts.push(null);\n    }\n\n    if (this.isIdPhantom(id)) {\n        sqls.push(&#39;INSERT INTO my_table (`parentid`, `text`) VALUES (&#39; + parentVar + &#39;, ?);&#39;);\n\n        inserts.push(\n            node.text\n        );\n\n        if (node.children) {\n            id = this.parsePhantomId(id);\n\n            //create the mapping of the phantom id to the SQL variable\n            vars[node.id] = &#39;@&#39; + id;\n\n            //use SET query to set the variable to the last inserted id\n            sqls.push(&#39;SET @&#39; + id + &#39; = LAST_INSERT_ID();&#39;);\n        }\n    } else {\n        this.realIds.push(id);\n\n        sqls.push(&#39;UPDATE my_table SET `parentid` = &#39; + parentVar + &#39;, `text` = ?  WHERE id = ?;&#39;);\n\n        inserts.push(\n            node.text,\n            id\n        );\n    }\n};</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So let’s take this slowly. First, we have to check if the <code class=\"language-text\">parentid</code> exists for the sake of if the node has a parent or if it’s a root child. This is also where we check if the parent is being created or updated. This also exposes the trick of handling create vs update, I use SQL variables. We’ll talk about that more in a bit. If the parent wasn’t a phantom (it already exists in the db) then we can set the <code class=\"language-text\">parentVar</code> variable to the <code class=\"language-text\">?</code> so that the mysql module can insert the parent’s id into the ending SQL query. If the parent is a phantom, then we are going to use the assigned SQL query for the parent node.</p>\n<p>Next, we handle the current node. We first check if the node’s <code class=\"language-text\">id</code> designates it as a phantom or not. If it does then we add the INSERT SQL query to the array of queries but we use that <code class=\"language-text\">parentVar</code> that is either <code class=\"language-text\">?</code> or the SQL variable. If the node has children, then we need to assign that node a SQL safe variable (using the <code class=\"language-text\">parsePhantomId</code> method that replaces hyphens with underscores), cache that SQL variable to the <code class=\"language-text\">vars</code> Object for lookup in child nodes and then add the SET SQL query that will set the SQL variable to the last insert id from the last INSERT query. So now we see something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">INSERT INTO my_table (`parentid`, `text`) VALUES (?, ?);\nSET @Model_1 = LAST_INSERT_ID();\nINSERT INTO my_table (`parentid`, `text`) VALUES (@Model_1, ?);\nSET @Model_3 = LAST_INSERT_ID();\nINSERT INTO my_table (`parentid`, `text`) VALUES (@Model_3, ?);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So now you can start to understand what I’m building. Using SQL variables to cache that real last insert id in the db will allow the whole tree data to be saved to the db in a single transaction. Of course if the node already exists I use an UPDATE instead of an INSERT and of course I don’t need to set a SQL variable since the parent exists. So I could have something like this if the first node existed:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">UPDATE my_table SET `parentid` = ?, `text` = ? WHERE id = ?;\nINSERT INTO my_table (`parentid`, `text`) VALUES (@Model_1, ?);\nSET @Model_3 = LAST_INSERT_ID();\nINSERT INTO my_table (`parentid`, `text`) VALUES (@Model_3, ?);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>However with a node that already exists, I do cache the real id to the <code class=\"language-text\">realIds</code> array so that I can delete all existing nodes that do not match those IDs since I expect the entire tree data to be sent back to the server.</p>\n<h3>Conclusion</h3>\n<p>I hope I didn’t loose you, it can be hard to blog about something like this and not just dump a bunch of code on you. I wanted to show that with a single flat array of SQL queries you can save a hierarchical tree structured data in a way where it can account for if the node and its parent are already existing in the database or not with the use of SQL variables. I’m really enjoying the actual simplicity of this and is thus far really working well. Like I said at the start, I am sending the entire data tree back which isn’t optimal but for a start is perfect. I’d have to deal with deletes and specifying the parent’s id on the client with the nodes being sent to the server to help with the relationship.</p>\n<p>Just in case the broken up code is a bit hard to follow, here is the <code class=\"language-text\">Tree.js</code> file I have:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">var mysql       = require(&#39;mysql&#39;),\n    phantomIdRe = /-/g;\n\nfunction Tree(data) {\n    this.data    = data;\n    this.sqls    = [];\n    this.inserts = [];\n    this.vars    = {};\n    this.realIds = [];\n\n    return this;\n}\n\nTree.prototype.isArray = function(value) {\n    return Object.prototype.toString.call(value) === &#39;[object Array]&#39;;\n};\n\nTree.prototype.isIdPhantom = function(id) {\n    return typeof id === &#39;string&#39; &amp;&amp; id.indexOf(&#39;-&#39;) &gt; -1;\n};\n\nTree.prototype.parsePhantomId = function(id) {\n    return id.replace(phantomIdRe, &#39;_&#39;);\n};\n\nTree.prototype.save = function(callback) {\n    var data    = this.data,\n        sqls    = this.sqls,\n        inserts = this.inserts,\n        tree;\n\n    this.parseChildren(data);\n\n    if (this.realIds &amp;&amp; this.realIds.length) {\n        sqls.unshift(&#39;DELETE FROM my_table WHERE id NOT IN(?);&#39;);\n        inserts.unshift(this.realIds);\n    }\n\n    //execute the sqls\n    console.log(mysql.format(sqls.join(&#39;&#39;), inserts));\n\n    callback();\n};\n\nTree.prototype.parseChildren = function(children, parent) {\n    if (!this.isArray(children)) {\n        children = children.children;\n    }\n\n    var i        = 0,\n        length   = children.length,\n        parentid = parent &amp;&amp; parent.id,\n        node;\n\n    if (length) {\n        for (; i &lt; length; i++) {\n            node = children[i];\n\n            this.parseNode(node, parentid);\n\n            if (node.children) {\n                this.parseChildren(node.children, node);\n            }\n        }\n    }\n};\n\nTree.prototype.parseNode = function(node, parentid) {\n    var sqls    = this.sqls,\n        inserts = this.inserts,\n        vars    = this.vars,\n        id      = node.id,\n        parentVar;\n\n    if (parentid) {\n        if (this.isIdPhantom(parentid)) {\n            parentVar = vars[parentid];\n\n            if (!parentVar) {\n                //no variable means it wasn&#39;t a phantom\n                parentVar = &#39;?&#39;;\n                inserts.push(parentid);\n            }\n        } else {\n            //wasn&#39;t a phantom\n            parentVar = &#39;?&#39;;\n            inserts.push(parentid);\n        }\n    } else {\n        //is a root child node\n        parentVar = &#39;?&#39;;\n        inserts.push(null);\n    }\n\n    if (this.isIdPhantom(id)) {\n        sqls.push(&#39;INSERT INTO my_table (`parentid`, `text`) VALUES (&#39; + parentVar + &#39;, ?);&#39;);\n\n        inserts.push(\n            node.text\n        );\n\n        if (node.children) {\n            id = this.parsePhantomId(id);\n\n            //create the mapping of the phantom id to the SQL variable\n            vars[node.id] = &#39;@&#39; + id;\n\n            //use SET query to set the variable to the last inserted id\n            sqls.push(&#39;SET @&#39; + id + &#39; = LAST_INSERT_ID();&#39;);\n        }\n    } else {\n        this.realIds.push(id);\n\n        sqls.push(&#39;UPDATE my_table SET `parentid` = &#39; + parentVar + &#39;, `text` = ? WHERE id = ?;&#39;);\n\n        inserts.push(\n            node.text,\n            id\n        );\n    }\n};\n\nmodule.exports = Tree;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>","fields":{"slug":"/2015/07/03/saving-hierarchal-data-in-mysql-with-node-js/"},"frontmatter":{"title":"Saving hierarchical data in MySQL with Node.js","date":"July 03, 2015"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2015/07/03/saving-hierarchal-data-in-mysql-with-node-js/","previous":{"fields":{"slug":"/2015/07/02/handling-user-session-with-routes/"},"frontmatter":{"title":"Handling user session with routes"}},"next":{"fields":{"slug":"/2015/07/13/ext-js-router-mixin/"},"frontmatter":{"title":"Ext JS Router Mixin!"}}}}}