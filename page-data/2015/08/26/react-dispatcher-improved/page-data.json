{"componentChunkName":"component---src-templates-blog-post-js","path":"/2015/08/26/react-dispatcher-improved/","webpackCompilationHash":"1f2b70db33523662b1d3","result":{"data":{"site":{"siteMetadata":{"title":"Mitchell Simoens Blog","author":"Mitchell Simoens"}},"markdownRemark":{"id":"baa540cb-5120-55d1-a58b-9f8da56de8a5","excerpt":"React is a very fast view layer and that’s it. Ok, we all know that (I hope). React doesn’t handle any business logic for user interactions. For example, if…","html":"<p><a href=\"https://facebook.github.io/react/\">React</a> is a very fast view layer and that’s it. Ok, we all know that (I hope). React doesn’t handle any business logic for user interactions. For example, if someone clicks on a button React doesn’t do anything. For that, you would need to use a dispatcher (or some other means).</p>\n<h2>Improved event handling</h2>\n<p>Luckily, <a href=\"https://www.facebook.com/\">Facebook</a> also has <a href=\"https://facebook.github.io/flux/\">Flux</a> which has a <a href=\"https://facebook.github.io/flux/docs/dispatcher.html#content\">dispatcher</a> class where you can register callback listeners for when something is dispatched. Here’s a simple example of this (taken from their documentation):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">var flightDispatcher = new Dispatcher();\n\nflightDispatcher.register(function(payload) {\n    if (payload.actionType === &#39;city-update&#39;) {\n        CityStore.city = payload.selectedCity;\n    }\n});\n\nflightDispatcher.dispatch({\n    actionType: &#39;city-update&#39;,\n    selectedCity: &#39;paris&#39;\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Ok, that’s pretty simple. However, in practice I don’t like one thing and that is when something is dispatched, <strong>ALL</strong> registered callbacks will execute. Each callback has to check if they care about the dispatched event. This seams quite wasteful and unneeded logic in the callback especially since you will likely have lots of registered callbacks. Sure, you can build something on top of it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">function callbackCreatorThing(property, value, callback) {\n    return function(payload) {\n        if (payload[property] === value) {\n            callback(payload);\n        }\n    }\n}\n\nflightDispatcher.register(\n    callbackCreatorThing(&#39;actionType&#39;, &#39;city-update&#39;, function(payload) {\n        CityStore.city = payload.selectedCity;\n    })\n);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So I created a function factory that will call the actual callback when <code class=\"language-text\">payload.actionType</code> is equal to <code class=\"language-text\">city-update</code>. Ok, so that’s not the end of the world and of course there are many other ways to do it but still… more work than you should have to do. I come from an <a href=\"https://www.sencha.com/products/extjs/\">Ext JS</a> world where things are event driven meaning you add a listener for when a certain event is driven. So I’d do something like this in Ext JS:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">cls.on(&#39;city-update&#39;, function(payload) {\n    CityStore.city = payload.selectedCity;\n});\n\ncls.fireEvent(&#39;city-update&#39;, payload);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So when the <code class=\"language-text\">fireEvent</code> is called, only those listeners listening to that event will be fired. So I need this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">flightDispatcher.register(&#39;city-update&#39;, function(payload) {\n    CityStore.city = payload.selectedCity;\n});\n\nflightDispatcher.dispatch(&#39;city-update&#39;, {\n    selectedCity: &#39;paris&#39;\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So I have to create my own dispatcher class (which is very easy). While I’m at it, why not extend this and allow certain actions to be dispatched and registered so a user can really get fine grained:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">flightDispatcher.register(&#39;city&#39;, &#39;update&#39;, function(payload, listener) {\n    CityStore.city = payload.selectedCity;\n});\n\nflightDispatcher.dispatch(&#39;city&#39;, &#39;update&#39;, {\n    selectedCity: &#39;paris&#39;\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Here, the event is <code class=\"language-text\">city</code> and the action being taken is <code class=\"language-text\">update</code>. I even get access to the listener. In fact, we could support all three cases:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">flightDispatcher.register(&#39;city&#39;, &#39;update&#39;, function(payload, listener) {\n    CityStore.city = payload.selectedCity;\n});\nflightDispatcher.register(&#39;city&#39;, function(payload, listener) {\n    //something happened to a city\n});\nflightDispatcher.register(function(payload, listener) {\n    //something happened\n});\n\nflightDispatcher.dispatch(&#39;city&#39;, &#39;update&#39;, {\n    selectedCity: &#39;paris&#39;\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>There are valid reasons to have catch all listeners like what Flux has.</p>\n<h2>Event Class</h2>\n<p>So the listening to dispatched events has been improved. However, there is one more thing that I like in Ext JS: the separate event (<code class=\"language-text\">Ext.event.Event</code>) class. This class holds many things but one thing I use a lot is the ability to stop an event in a listener. Maybe some business logic says that the user isn’t able to update a city, then you should be able to stop an event from firing other listeners. For this, I created a separate Event class which the Dispatcher creates when it finds all the listeners for the event and action being dispatched. So now you can do this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">flightDispatcher.register(&#39;city&#39;, &#39;update&#39;, function(e) {\n    e.stop();\n});\nflightDispatcher.register(&#39;city&#39;, function(e) {\n    //something happened to a city\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>In the first registered callback, I stop the event from firing so the second registered callback will not be executed. This gives further control over the flow of the events in an application.</p>\n<h2>Conclusion</h2>\n<p>Using React with Flux versus using Ext JS shows how mature Ext JS is, it’s been around for almost 10 years now so I’d expect it to be. However, this doesn’t mean that some ideas from Ext JS cannot be applied to a React application.</p>\n<p>I’ve quickly put the code up on <a href=\"https://github.com/mitchellsimoens/react-idispatcher\">GitHub</a> and <a href=\"https://www.npmjs.com/package/react-idispatcher\">npm</a>. The dispatcher class is a singleton (I create an instance and return it in <code class=\"language-text\">module.exports</code> as there really should only be one message bus.</p>","fields":{"slug":"/2015/08/26/react-dispatcher-improved/"},"frontmatter":{"title":"React dispatcher, improved","date":"August 26, 2015"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2015/08/26/react-dispatcher-improved/","previous":{"fields":{"slug":"/2015/08/15/this-is-undefined-what/"},"frontmatter":{"title":"this is undefined, what?"}},"next":{"fields":{"slug":"/2015/09/17/sftp-server-in-node-js/"},"frontmatter":{"title":"SFTP server in Node.js"}}}}}