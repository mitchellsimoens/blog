{"componentChunkName":"component---src-templates-blog-post-js","path":"/2016/12/20/new-router-for-ext-js/","webpackCompilationHash":"56543836aa9ef392dae0","result":{"data":{"site":{"siteMetadata":{"title":"Mitchell Simoens Blog","author":"Mitchell Simoens"}},"markdownRemark":{"id":"ff00ecef-5477-5bde-92ee-1f228058f185","excerpt":"When Fiddle 1 was being developed back in 2013, Ext JS 5 was in development. At that time, Ext JS did not have a router but Fiddle did. It was obvious that…","html":"<p>When Fiddle 1 was being developed back in 2013, Ext JS 5 was in development. At that time, Ext JS did not have a router but Fiddle did. It was obvious that users of Ext JS would benefit so the router was implemented in Ext JS from what Fiddle did. Fast forward to today and we have a new support portal and a new fiddle and there are many things I needed from the router that the router simply did not support. So those new web apps are using a highly overridden router; wouldn’t it be great if Ext JS’ router would get an update with some of these new things? I thought so, so the next major version of Ext JS has an updated router and I’d like to take a minute to describe some of the updates.</p>\n<h3>Update (02-13-2016)</h3>\n<p>This will be part of the Ext JS 6.5 release. I do not have a release date to provide at this time.</p>\n<h1>Mixin</h1>\n<p>One thing I’ve seen many people ask for is a mixin to allow any class to use routes. This can be either because you aren’t using an architecture (MVC or MVVM) or your application is structured to use utility singletons. Regardless the reasoning, we will have <code class=\"language-text\">Ext.route.Mixin</code> so that you can use the router wherever you want… even a store if that’s your thing.</p>\n<h1>Global befores</h1>\n<p>The support portal requires a user to be logged in, fiddle wants to know the session state up-front. Therefore, the routes need to not fire before the session is checked. The way I was doing this was to have a shared before action but this didn’t scale very well. What is needed is a global means to have a before action to delay all routes. The router now has a wildcard route concept that will always fire before all routes:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">routes : {\n    &#39;*&#39; : {\n        before : &#39;onBeforeRoute&#39;\n    }\n}</code></pre></div>\n<p>And like any other before, you just need to execute that <code class=\"language-text\">action.resume()</code> or <code class=\"language-text\">action.stop()</code>. A great place for this would be in your <code class=\"language-text\">Application</code> class.</p>\n<h1>Promise support in befores</h1>\n<p>One drawback to how befores work is the <code class=\"language-text\">action</code> argument is always the last argument which is important for routes having variable number of url parameters. It’s not that it’s hard to get the last argument, it’s just a bit ugly to always have that code. Also, if you’ve follow me on <a href=\"https://www.twitter.com/LikelyMitch\">twitter</a>, you may have noticed that I used to hate promises but now am a lover. So you can now use promises and <code class=\"language-text\">resolve()</code> or <code class=\"language-text\">reject()</code> to resume or stop the route’s execution:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">onBeforeRoute : function() {\n    return new Ext.Promise((resolve, reject) =&gt; {\n        setTimeout(() =&gt; {\n            resolve();\n        }, 500);\n    });\n}</code></pre></div>\n<p>Now you don’t need to find that last argument and some Ext JS classes support promises in their API so it feels much more natural. But the choice is yours, just don’t choose both. :)</p>\n<h1>Named routes</h1>\n<p>The support portal and fiddle use multiple tokens in the document fragment. In fiddle, you may see <code class=\"language-text\">view/editor&amp;fiddle/abc</code> and there are two tokens/routes there: <code class=\"language-text\">view/editor</code> and <code class=\"language-text\">fiddle/abc</code>. Click on the search icon on the left and it updates to <code class=\"language-text\">view/search&amp;fiddle/abc</code>. To do this with out-of-the-box router in Ext JS 5 or 6, you’d have to manually parse out the string and replace the single token, definitely not developer friendly.</p>\n<p>To solve this, a route can be named. So for this example, I could have this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">routes : {\n    &#39;fiddle/:id&#39; : {\n        action : &#39;onFiddleChange&#39;,\n        name   : &#39;fiddle&#39;\n    },\n    &#39;view/:type&#39; : {\n        action : &#39;onViewChange&#39;,\n        name   : &#39;view&#39;\n    }\n}</code></pre></div>\n<p>In fiddle, I now can use <code class=\"language-text\">redirectTo</code> with an <code class=\"language-text\">Object</code> to update that one view token but leave the fiddle one alone:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">this.redirectTo({\n    view : &#39;view/search&#39;\n});</code></pre></div>\n<p>If I wanted to remove the fiddle token but leave the view one intact, just pass <code class=\"language-text\">null</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">this.redirectTo({\n    fiddle : null\n});</code></pre></div>\n<p>and the document fragment will then be <code class=\"language-text\">view/editor</code>. You can still pass a <code class=\"language-text\">String</code> to <code class=\"language-text\">redirectTo</code> if you want to completely replace the entire document fragment like you would in Ext JS 5 and 6.</p>\n<p><strong>Note:</strong> If you do not specify a name in the route object, it will default to the url provided. So the name of this route would be <code class=\"language-text\">view/:type</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">routes : {\n    &#39;view/:type&#39; : &#39;onViewChange&#39;\n}</code></pre></div>\n<p>but that’s not really friendly but can be useful.</p>\n<h1>New <code class=\"language-text\">Action</code> class</h1>\n<p>In a route’s before function, you may have used or seen the <code class=\"language-text\">action</code> argument. Before, this was just an <code class=\"language-text\">Object</code> literal with a <code class=\"language-text\">resume</code> and <code class=\"language-text\">stop</code> function. We are now elevating this to a class to add additional functionality and is really much more than that old <code class=\"language-text\">Object</code> literal. The job of the <code class=\"language-text\">Action</code> class is more of a runner when a route is being executed. An <code class=\"language-text\">Action</code> may have multiple <code class=\"language-text\">before</code> and <code class=\"language-text\">action</code> functions that need to be executed in sequence.</p>\n<p>Within a <code class=\"language-text\">before</code> action, you can now add a <code class=\"language-text\">before</code> or <code class=\"language-text\">action</code> as you please:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">action.before((action) =&gt; {\n    action.resume();\n});</code></pre></div>\n<p>You can also add handlers when the <code class=\"language-text\">Action</code> class has either been fully resolved or if it was stopped by using the <code class=\"language-text\">then</code> method:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">action.then(function() {}, function() {});</code></pre></div>\n<h1>Suspend/Resume the router</h1>\n<p>This is one feature I didn’t have a need for personally but I have been asked about it and it’s simple to implement. If you want to suspend the router completely during some task, you will be able to:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.route.Router.suspend();\nExt.route.Router.resume();</code></pre></div>\n<p>Boom! Done! Exactly like <a href=\"http://docs.sencha.com/extjs/6.2.1/classic/Ext.mixin.Observable.html#method-suspendEvents\">suspendEvents</a> and <a href=\"http://docs.sencha.com/extjs/6.2.1/classic/Ext.mixin.Observable.html#method-resumeEvents\">resumeEvents</a>, you can also tell the <code class=\"language-text\">suspend</code> method to queue the routes while the router is suspended or discard the routes when the <code class=\"language-text\">resume</code> method is executed:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ext.route.Router.suspend(false); //will not queue routes while is suspended\nExt.route.Router.resume(true);   //will dump the queue before it is resumed</code></pre></div>\n<h1>Unit tests</h1>\n<p>In today’s Sencha, having unit tests is a priority. We now have over a hundred unit tests for the 4 classes. Do note, you can never say you have enough unit tests so the number will be growing (100% code coverage !== no bugs).</p>","fields":{"slug":"/2016/12/20/new-router-for-ext-js/"},"frontmatter":{"title":"New Router for Ext JS","date":"December 20, 2016"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2016/12/20/new-router-for-ext-js/","previous":{"fields":{"slug":"/2016/07/21/websockets-behind-elastic-beanstalk/"},"frontmatter":{"title":"WebSockets Behind Elastic Beanstalk"}},"next":{"fields":{"slug":"/2017/04/12/package-loading/"},"frontmatter":{"title":"Package Loading on the Fly"}}}}}