{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/2014/12/19/mon-vs-on/","result":{"data":{"site":{"siteMetadata":{"title":"Mitchell Simoens Blog","author":"Mitchell Simoens"}},"markdownRemark":{"id":"c4811378-954c-5a91-a4de-397c2824c775","excerpt":"A common method when developing an application is to be event driven. This allows your code to be very flexible. Not being event driven can lead to code that is…","html":"<p>A common method when developing an application is to be event driven. This allows your code to be very flexible. Not being event driven can lead to code that is very intimate to the current state of your application. Change or add something later on and you must go through your application and change the different parts where as being event driven allows an event to be fired and forgotten about. Anything listening to that event can then take action on that event but not be dependant on what fired the event.</p>\n<p>A simple example is an email application.  Say a user sends an email, when the email has been sent and the server returns success, the callback may fire an event to tell anything in the application that the user sent an email. The Sent folder list may listen to this event in order to reload the list. This email may have been sent from different forms, a create email form may be different than a quick reply form but that doesn’t matter, either form may fire the same event and the Sent folder list doesn’t care where it came from. This is flexibility and in my eyes, creates much safer code.</p>\n<h2>Adding listeners in Ext JS</h2>\n<p>Ext JS allows many different ways to add listeners but today I want to speak about <code class=\"language-text\">mon</code> and <code class=\"language-text\">on</code> and the differences. First, let’s start with <code class=\"language-text\">on</code>.</p>\n<h3><code class=\"language-text\">on</code></h3>\n<p>The simplest of the two is the <code class=\"language-text\">on</code> method which can simply add an event listener:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">component.on(&#39;foo&#39;, someFunc, component);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>You can also pass an object for a convenient way to add multiple listeners:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">component.on({\n    scope : component,\n    foo   : someFunc,\n    bar   : someOtherFunc\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This will add listeners for the <code class=\"language-text\">foo</code> and <code class=\"language-text\">bar</code> events and scope them to the <code class=\"language-text\">component</code> variable. In Ext JS 4 and newer, listeners defined this way will automatically get removed when the component is destroyed thanks to the <code class=\"language-text\">clearListeners</code> method being executed in the <code class=\"language-text\">destroy</code> method of <code class=\"language-text\">Ext.Component</code>.</p>\n<h3><code class=\"language-text\">mon</code></h3>\n<p><code class=\"language-text\">mon</code> works just like <code class=\"language-text\">on</code> when defining a listener only the first argument must be a class to add the listeners too. That’s a bit confusing of a statement right? Let’s look at an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">component.mon(subClass, &#39;foo&#39;, someFunc, component);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>What this is doing, is adding a listener for the <code class=\"language-text\">foo</code> event that will be fired on the <code class=\"language-text\">subClass</code> variable. Once fired, it will execute the <code class=\"language-text\">someFunc</code> function scoped to the <code class=\"language-text\">component</code> variable but the listener is added to the <code class=\"language-text\">component</code> but the event will be fired on the <code class=\"language-text\">subClass</code>.</p>\n<p>The benefit here is the component can listen to an event on something else but when the component is destroyed, this listener is removed. The component may be destroyed but the <code class=\"language-text\">subClass</code> variable may still live on; the component is managing the <code class=\"language-text\">foo</code> event listener.</p>\n<p>Like the <code class=\"language-text\">on</code> method, you can also pass an object:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">component.mon(subClass, {\n    scope : component,\n    foo   : someFunc,\n    bar   : someOtherFunc\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h3>Difference</h3>\n<p>Let’s think of an <code class=\"language-text\">Ext.Component</code> instance that wants to listen to a <code class=\"language-text\">store</code> load. You can use <code class=\"language-text\">on</code> like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">store.on(&#39;load&#39;, this.onStoreLoad, this);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>However, when the <code class=\"language-text\">Ext.Component</code> is destroyed, the listener will not be removed because the event listener is on the <code class=\"language-text\">store</code> not the <code class=\"language-text\">Ext.Component</code>. This causes a memory leak and the next <code class=\"language-text\">store</code> load after the component is destroyed will likely throw an error, both bad things. This is where <code class=\"language-text\">mon</code> would be a better use:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">this.mon(store, &#39;load&#39;, this.onStoreLoad, this);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>This adds a <code class=\"language-text\">load</code> listener on the store but is being managed by the <code class=\"language-text\">Ext.Component</code>. When the <code class=\"language-text\">Ext.Component</code> is destroyed, the listener is removed. The <code class=\"language-text\">store</code> is then free to live on and fire it’s <code class=\"language-text\">load</code> event without errors being thrown and no memory leaks are present.</p>","fields":{"readingTime":{"text":"4 min read"},"slug":"/2014/12/19/mon-vs-on/"},"frontmatter":{"title":"A Naming Strategy","date":"December 19, 2014"}}},"pageContext":{"slug":"/2014/12/19/mon-vs-on/","previous":{"fields":{"slug":"/2014/12/18/store-listeners/"},"frontmatter":{"title":"Store Listeners"}},"next":{"fields":{"slug":"/2015/01/07/a-naming-strategy/"},"frontmatter":{"title":"A Naming Strategy"}}}},"staticQueryHashes":["63159454","734670849"]}