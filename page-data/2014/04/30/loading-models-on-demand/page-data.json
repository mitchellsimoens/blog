{"componentChunkName":"component---src-templates-blog-post-js","path":"/2014/04/30/loading-models-on-demand/","webpackCompilationHash":"56543836aa9ef392dae0","result":{"data":{"site":{"siteMetadata":{"title":"Mitchell Simoens Blog","author":"Mitchell Simoens"}},"markdownRemark":{"id":"9f79ff83-df18-5567-8b25-f935d9dba12c","excerpt":"There are use cases where a model’s fields need to be loaded from the server so your application can be dynamic and even automatically maintained via the…","html":"<p>There are use cases where a model’s fields need to be loaded from the server so your application can be dynamic and even automatically maintained via the database design changing or some server side update. I recently read a blog post that talked about the same thing but I felt the solution provided was too simplistic and didn’t make use of functionality already in Ext JS. So I wanted to create an example of how I would do it.</p>\n<h2>Requirements</h2>\n<p>Before we start coding, lets map out our requirements:</p>\n<ul>\n<li>A store needs to load the model data from the server.</li>\n<li>We need to reuse the model when it is created from server side data so we don’t keep creating model definitions.</li>\n</ul>\n<p>Pretty simple requirements. The issue with the solution I saw was the second requirement. In that blog post, the store was sending an <code class=\"language-text\">Ext.Ajax.request</code> to load the fields every time a store instance was created. This is unnecessary as once you have the fields for the model and the model has been defined, you no longer need to do another ajax request to load the fields again. Also, the solution used <code class=\"language-text\">Ext.Ajax.request</code> which means you are locked into using it. One last issue with that solution: what if the store auto-loaded and it took less time than the request loading the model fields? You have a racing condition that you can never 100% say will work; network latency, server issues, etc all play a part.</p>\n<h2>Ext JS Native Functionality</h2>\n<p>I mentioned before about the other solution not using functionality that Ext JS already has. When the reader (the <code class=\"language-text\">Ext.data.reader.*</code>) is asked to read the data (readRecords method), it checks to see if there is a <code class=\"language-text\">metaData</code> field in the raw response and if so will execute it’s <code class=\"language-text\">onMetaChange</code> method which will then define a new model with the fields returned among other things. Here is the <code class=\"language-text\">onMetaChange</code> method, the code speaks for itself:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">onMetaChange : function(meta) {\n    var me = this,\n        fields = meta.fields || me.getFields(),\n        model,\n        newModel,\n        clientIdProperty,\n        proxy;\n\n    // save off the raw meta data\n    me.metaData = meta;\n\n    // set any reader-specific configs from meta if available\n    if (meta.root) {\n        me.setRootProperty(meta.root);\n    }\n\n    if (meta.totalProperty) {\n        me.setTotalProperty(meta.totalProperty);\n    }\n\n    if (meta.successProperty) {\n        me.setSuccessProperty(meta.successProperty);\n    }\n\n    if (meta.messageProperty) {\n        me.setMessageProperty(meta.messageProperty);\n    }\n\n    clientIdProperty = meta.clientIdProperty;\n\n    newModel = Ext.define(null, {\n        extend: &#39;Ext.data.Model&#39;,\n        fields: fields,\n        clientIdProperty: clientIdProperty\n    });\n    me.setModel(newModel);\n    proxy = me.getProxy();\n    if (proxy) {\n        proxy.setModel(newModel);\n    }\n    me.buildExtractors(true);\n}</code></pre></div>\n<p>As you can see, the <code class=\"language-text\">metaData</code> allows you to set the root, total, success and message properties but also is going to define a model. Here is an example JSON response that will make the reader execute this method:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    &quot;metaData&quot; : {\n        fields : [...]\n    },\n    ...\n}</code></pre></div>\n<h2>Caching</h2>\n<p>So now we know that Ext JS can accept metaData to create a new model as we want but the second requirement is we only want to load it once so we need some sort of way to selectively tell the server to return the meta and we also need to cache the model definition for subsequent store instances. Since I may have multiple store definitions that need to use this and I don’t want too much logic in my stores; I like to use a singleton class as a utility class. In this example app, I have a singleton class called <code class=\"language-text\">MyApp.util.StoreModelCache</code> located at <code class=\"language-text\">app/util/StoreModelCache.js</code>. What this class does is holds an object mapping store class names to model definition. If a model is not cached yet, it adds a <code class=\"language-text\">beforeload</code> event listener so that it can add a parameter (<code class=\"language-text\">needsModel</code> for this example) to the request to tell the server to return the meta data for the model. It will also add a <code class=\"language-text\">load</code> event listener to then cache the model definitionx the reader created. To kick off the use of the <code class=\"language-text\">MyApp.util.StoreModelCache</code> class, in the <code class=\"language-text\">constructor</code> method of the <code class=\"language-text\">MyApp.store.Cached</code> store, I execute the get method on the <code class=\"language-text\">MyApp.util.StoreModelCache</code> class which returns the model definition from the cache and if one doesn’t exist it will add the event listeners.</p>\n<p>Do note, I don’t use <code class=\"language-text\">MyApp.store.Cached</code> in my grid, I use <code class=\"language-text\">MyApp.store.Users</code> and have that store extend <code class=\"language-text\">MyApp.store.Cached</code> to give a good example as to how you can then have multiple stores reuse the logic.</p>\n<p>To summarize it, the <code class=\"language-text\">MyApp.util.StoreModelCache</code> holds model definitions in a cache. If one doesn’t exist, it tells the server to return the model meta data and caches the model definition when it’s created.</p>\n<h2>Example</h2>\n<p>The example consists of an Ext JS 5 application that has a grid, the stores and the singleton. The example also comes with a PHP script that will load the data and such from a MySQL database. I provide a <code class=\"language-text\">data.sql</code> file that I used for my testing.</p>\n<p>Once you get the SQL file imported into a MySQL and you setup the MySQL connection details at the top of <code class=\"language-text\">data.php</code>, you can then run the Ext JS 5 app. The <code class=\"language-text\">MyApp.store.Users</code> store will automatically load so wait a couple seconds for it to load and you should see 2 rows in the grid. If you look at the network tab in the dev tools, you will see a request to <code class=\"language-text\">data.php</code> that has the <code class=\"language-text\">needsModel</code> parameter and therefore the response contains the <code class=\"language-text\">metaData</code> data which then the reader created the model definition.</p>\n<p>The grid has 2 tools:</p>\n<ul>\n<li><strong>refresh</strong> This will reload the store which shouldn’t send the <code class=\"language-text\">needsModel</code> parameter as the model should have been cached.</li>\n<li><strong>recreate</strong> This will destroy the current grid and recreate the grid. I have this so the grid will get a new store instance to show that the model definition created in the first instance was cached.</li>\n</ul>\n<p>The example is hosted on GitHub: <a href=\"https://github.com/mitchellsimoens/ModelOnDemand\" target=\"_blank\">here</a></p>","fields":{"slug":"/2014/04/30/loading-models-on-demand/"},"frontmatter":{"title":"Loading Model Data on Demand","date":"April 30, 2014"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2014/04/30/loading-models-on-demand/","previous":{"fields":{"slug":"/2014/04/01/ext-create-or-ext-widget-or-new-what-the-heck/"},"frontmatter":{"title":"Ext.create or Ext.widget or new... what the heck?"}},"next":{"fields":{"slug":"/2014/10/27/tough-mudder-looking-ahead-for-2015/"},"frontmatter":{"title":"Tough Mudder - Looking ahead for 2015"}}}}}