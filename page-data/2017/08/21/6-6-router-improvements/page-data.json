{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/2017/08/21/6-6-router-improvements/","result":{"data":{"site":{"siteMetadata":{"title":"Mitchell Simoens Blog","author":"Mitchell Simoens"}},"markdownRemark":{"id":"c0cef332-958b-56e8-bc26-b1981bd50f98","excerpt":"If you know me, you know that the router is very important to every application I build. And like every iteration of Ext JS’ router, Sencha Fiddle is the…","html":"<p>If you know me, you know that the router is very important to every application I build. And like every iteration of Ext JS’ router, <a href=\"https://fiddle.sencha.com/\">Sencha Fiddle</a> is the application that has the most contribution and the most experimentation (Sencha Fiddle has a custom router with overrides to add new features to the Ext JS version it’s using) on the router. Once again, with Ext JS 6.6, Sencha Fiddle exposed some features that would be great but it’s also talking to the community that has provided many improvements as well. I want to talk about four new features that have landed in 6.6.</p>\n<h1>Exit Handler</h1>\n<p>This feature came from a community member (<a href=\"https://www.sencha.com/forum/member.php?210320-LesJ\">LesJ</a> from the Sencha Forums).</p>\n<p>There are many times when you create things in response to a route being executed that you may need to cleanup. For example, you may have opened an <a href=\"https://docs.sencha.com/extjs/latest/classic/Ext.window.Window.html\">Ext.window.Window</a> but when the route is executed, you need to close that window. So in your <code class=\"language-text\">action</code> handler, you create the window and likely cache it somewhere and when another route is executed you check to see if any windows are shown and clean that up. Ok, not the end of the world but this means code starts to get ugly and brittle and you start engineering things where Ext JS could make this easy.</p>\n<p>With Ext JS 6.6, we are going to make this easy with a new <code class=\"language-text\">exit</code> handler and the use of it is just like the <code class=\"language-text\">action</code> and <code class=\"language-text\">before</code> handler:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">routes : {\n    &#39;foo/bar&#39; : {\n        action : &#39;onFoo&#39;,\n        exit   : &#39;onExit&#39;,\n        name   : &#39;foo&#39;\n    }\n},\n\nonFoo : function () {},\n\nonExit : function () {}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So now your route can handle when the route no longer recognizes anything in the hash. Internally, each route keeps track of the last token it was executed on which allows it to know if it was being exited which is needed if you use multiple tokens as is the case in my apps like Sencha Fiddle.</p>\n<h1>Single Routes</h1>\n<p>This improvement comes from a need for Sencha Fiddle.</p>\n<p>At the start of Sencha Fiddle (and the support portal) I have to check user session and I also wait for certain stores to load before I want to continue with showing views and such. Currently, I have a global route with a before, here is a small example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">routes : {\n    &#39;*&#39; : {\n        before : &#39;onBeforeGlobal&#39;\n    }\n},\n\nonBeforeGlobal : function () {\n    return new Ext.Promise(function (resolve, reject) {\n        // check if things have finished loading\n    });\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>I have an array of stores I go through and check if it has <a href=\"https://docs.sencha.com/extjs/latest/classic/Ext.data.ProxyStore.html#method-isLoaded\">loaded</a>. However, I felt like this was wasteful because it’s going to check if these stores are loaded for each route as the <code class=\"language-text\">*</code> wildcard route fires before all other routes; I only needed it to check upfront. Taking a page out of the Observable listeners where you can pass <code class=\"language-text\">single: true</code>, routes will be able to define their singleness:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">routes : {\n    &#39;*&#39; : {\n        before : &#39;onBeforeGlobal&#39;,\n        single : true\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Tough syntax huh? This will remove the route from the router after the <code class=\"language-text\">before</code> and <code class=\"language-text\">action</code> handlers have been executed. Once removed, the route will not longer be connected and will not execute anymore. Perfect!</p>\n<p>Or is it? Why wait for a full, successful execution to remove the route? Why not always remove it? Knowing that all applications (or developers) do not have the same requirements, we decided to give a bit more control and so the <code class=\"language-text\">single</code> option can also accept <code class=\"language-text\">&#39;before&#39;</code> and <code class=\"language-text\">&#39;after&#39;</code>. These string values are about when to remove the route.</p>\n<p><code class=\"language-text\">&#39;before&#39;</code> will remove the route before the configured <code class=\"language-text\">before</code> handler is executed. This means the route will always get removed regardless if the <code class=\"language-text\">before</code> action is resolved or rejected.</p>\n<p><code class=\"language-text\">&#39;after&#39;</code> will remove the route right after the <code class=\"language-text\">before</code> handler has been resolved but prior to the <code class=\"language-text\">action</code> handler to be removed. This can be seen as very similar to the <code class=\"language-text\">true</code> value since the <code class=\"language-text\">action</code> handler cannot be stopped (assuming to errors occur), however, the difference is when you have other routes that have a <code class=\"language-text\">before</code>. Those other <code class=\"language-text\">before</code>s may reject which would then not execute our single route’s <code class=\"language-text\">action</code> handler from executing which means the route would not get removed.</p>\n<p>Kind of hard to grok fully from just text so I’ll try another way of explaining it. When you defined the <code class=\"language-text\">routes</code> config, it will actually only create one route instance matching the route name (or pattern) and the <code class=\"language-text\">before</code>/<code class=\"language-text\">action</code> handlers are then added to that route’s <code class=\"language-text\">handlers</code> array. So when a hash changes, it finds the matching route instance and then executes it. It creates two arrays: the <code class=\"language-text\">before</code>s and the <code class=\"language-text\">action</code>s. Execution will go through each before in an async stack (each before has to resolve before moving onto the next before) and then it will go through the action stack. So there are three insert points on where the route can be removed: beginning of the before stack, within the before stack after the matching <code class=\"language-text\">before</code> action, and on the end of the action stack. So it’s very important to know when you’d want the route to be removed in that execution but the main point is whether to wait for a <code class=\"language-text\">before</code> or all <code class=\"language-text\">before</code>s to resolve.</p>\n<p>We picked <code class=\"language-text\">true</code> to remove on the end of the action stack but are still discussing whether it should go on the beginning of the before stack so these values may change. This will be documented in the API Docs when 6.6 is released so I would recommend checking the final docs. Also, comment below if you feel strongly about this. I’ll even see if I can create an example and/or image to show this a bit better, I’m still trying to find a great way to explain it with so many duplicate terms.</p>\n<h1>Lazy Routes</h1>\n<p>This feature came out from the <a href=\"https://github.com/sencha-extjs-examples/Coworkee\">coworkee app</a> that was developed internally among some posts on the forum.</p>\n<p>One issue with using routes in ViewControllers is that the ViewController may not be instantiated when the route was already executed. I personally don’t spread routes around too much but people have been asking for this and it was easy to implement so ok. People asked for the routes defined on their ViewController to execute if it matches a current hash. We are calling this <code class=\"language-text\">lazy</code> and it can be defined like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">routes : {\n    &#39;user/:id&#39; : {\n        action  : &#39;onUser&#39;,\n        lazy    : true,\n        name    : &#39;user&#39;\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This means, if the hash is already <code class=\"language-text\">#user/1234</code> when the ViewController is instantiated, this route will execute.</p>\n<p>I’m personally not a fan of defining routes all around my application but I do see some value it in since I’ve built some heinous enterprise UIs and routes may only update a portion of the screen not simply swap out what view is in the center/content region.</p>\n<h1>Named Types</h1>\n<p>This feature came from a mix of things from Fiddle to support tickets to a conversation between Don Griffin and I. This feature also aims to fix two different problems.</p>\n<p>Ok, I teased this on Twitter and here is what this was about.</p>\n<p>The first “problem” is people currently have to define custom matching RegExp strings to control the format of a url parameter. What I mean is say you have a user route that accepts an ID but that ID will only be numeric so you can define it as such:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">routes : {\n    &#39;user/:id&#39; : {\n        action     : &#39;onUser&#39;,\n        name       : &#39;user&#39;,\n        conditions : {\n            &#39;:id&#39; : &#39;([0-9]+)&#39;\n        }\n    }\n},\n\nonUser : function (id) {}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Now, this route will only execute for hashes where <code class=\"language-text\">:id</code> is numeric such as <code class=\"language-text\">user/1234</code> but will not execute if there are other characters such as <code class=\"language-text\">user/1234abc</code>. One important note to make here is the <a href=\"https://docs.sencha.com/extjs/latest/classic/Ext.route.Route.html#property-defaultMatcher\">defaultMatcher</a> of a route is <code class=\"language-text\">([%a-zA-Z0-9\\\\-\\\\_\\\\s,]+)</code> so it will accept a few different characters that you may or may not want.</p>\n<p>My initial proof of concept had a syntax such as :</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">routes : {\n    &#39;user/:num&#39; : {\n        action : &#39;onUser&#39;,\n        name   : &#39;user&#39;\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>And that <code class=\"language-text\">:num</code> would automatically use the <code class=\"language-text\">([0-9]+)</code> RegExp. This is pretty simple right? The issue with this syntax is what if you had a <code class=\"language-text\">:num</code> parameter in a route but didn’t want that exact RegExp? There was also <code class=\"language-text\">:alpha</code> and <code class=\"language-text\">:alphanum</code>. The chance of collision here was very tiny but if you were one of the unlucky people that would have a name conflict, it likely would be a silent failure and you’d find out about it in production which is not good at all. So we discussed how we can prevent this and a couple different ideas came up like <code class=\"language-text\">:$num</code> or some character to signify this was to be treated as a named type. But we decided on this format:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">routes : {\n    &#39;user/:{id:num}&#39; : {\n        action : &#39;onUser&#39;,\n        name   : &#39;user&#39;\n    }\n},\n\nonUser : function (params) {\n    var id = params.id;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So we surround the parameter name and type in curly braces. Quick note, the type (<code class=\"language-text\">:num</code> in this case) is optional so you can have <code class=\"language-text\">:{id}</code> and the <code class=\"language-text\">defaultMatcher</code> will then be used. Other default types are <code class=\"language-text\">:alpha</code> and <code class=\"language-text\">:alphanum</code>. Also, for <code class=\"language-text\">:num</code> and <code class=\"language-text\">:alphanum</code>, numbers will be cast using <code class=\"language-text\">parseFloat</code> so you can have <code class=\"language-text\">#foo/10.4</code> and 10.4 will be a float instead of just a string.</p>\n<p>Also notice in the <code class=\"language-text\">onUser</code> we have <code class=\"language-text\">params</code> which will be an object and the parameter names will not be the key of that object. This was another of the problems where having separate arguments in the functions could get a bit wildly and it can be a good rule of thumb if you have more than 3 arguments, an object will be more friendly. So if you use these new named typed, an object will always be passed to the handlers.</p>\n<p>We have some detection if you reuse a param name, an error will be thrown in the console with what name was duplicated and what route this was defined in. So if you have <code class=\"language-text\">user/:{id}/:{id}</code>, you’d get an error in the console such as:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">&quot;id&quot; already defined in route &quot;user/:{id}/:{id}&quot;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Also, if you have a type that is not known, you’ll also get an error. So say you have <code class=\"language-text\">user/:{id:foo}</code>, <code class=\"language-text\">:foo</code> is not a default type so you’d get this error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Unknown parameter type &quot;foo&quot; in route &quot;user/:{id:foo}&quot;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Since there is a difference between how the parameters are passed to the handlers, we don’t want the two syntaxes mixed in a route. The older syntax is called “positional” and the newer being called “named”. If you mix these syntaxes like so: <code class=\"language-text\">foo/:bar/:{baz}</code> you will get the error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">URL parameter mismatch. Positional url parameter found while in named mode in the route &quot;foo/:bar/:{baz}&quot;.</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>A couple thoughts here on the duplicate parameters. Right now, you cannot have duplicate parameter names in the same route. However, we’ve discussed turning the single value into an array to support duplicate names, however, we don’t really think this will be something that many will use and an error may be more helpful. Once again, let us know your thoughts as we can have a config to allow this if people would want it, just provide us with a real world scenario where you’d want it.</p>\n<p>You can define your own custom named types via an override. For example, in Sencha Fiddle a fiddle id will only be <code class=\"language-text\">[a-z0-9]</code> and I can have the route defined in a couple places so having a central place to have this and be able to be used anywhere would be a big pro. So you can add one:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Ext.define(&#39;Override.route.Route&#39;, {\n    override : &#39;Ext.route.Route&#39;,\n\n    config : {\n        types : {\n            &#39;fiddleid&#39; : {\n                re : &#39;([a-z0-9]+)&#39;\n            }\n        }\n    }\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Now I can define routes such as:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">routes : {\n    &#39;fiddle/:{id:fiddleid}&#39; : {\n        action : &#39;onFiddle&#39;,\n        name   : &#39;fiddle&#39;\n    }\n},\n\nonFiddle : function (params) {\n    Ext.Ajax\n        .request({\n            url : &#39;/fiddle/get/&#39; + params.id\n        })\n        .then(function (fiddle) {\n            // ...\n        });\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So since we are now parsing parameters and their types, there is one thing that I’ve seen people ask for and that would be supporting an arbitrary number of parameters in a hash. For example, say you want to support hashes like <code class=\"language-text\">#view/foo</code> and <code class=\"language-text\">#view/foo/bar/baz</code> in a single route. Before, you’d have to do something complex with conditions and if you didn’t want to get too complex, you’d have a static number of parameters defined in your pattern like <code class=\"language-text\">view/:foo/:bar/:baz</code> (this isn’t a very good, full example of what would be needed). So we are attempting to handle this with this syntax:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">routes : {\n    &#39;view/:{args...}&#39; : {\n        action : &#39;onView&#39;,\n        name   : &#39;view&#39;\n    }\n},\n\nonView : function (params) {\n    // Ext.isArray(params.args) === true\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>By default, this syntax will match everything (uses <code class=\"language-text\">(.+)?</code>) and split on <code class=\"language-text\">/</code> so that you get an array of values. Like the <code class=\"language-text\">:num</code> and <code class=\"language-text\">:alphanum</code>, this will also attempt to cast numbers into floats. So if you have this hash <code class=\"language-text\">#view/foo/12.45/bar</code>, this is what the params object would be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">{\n    args : [ &#39;foo&#39;, 12.45, &#39;bar&#39; ]\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>As you would expect, you don’t need to have just the one parameter, you can have other parameters with their own types:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">routes : {\n    &#39;view/:{which}/:{amount:num}:{args...}&#39; : {\n        action : &#39;onView&#39;,\n        name   : &#39;view&#39;\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>The params object would then be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">{\n    amount : 12.45,\n    args   : [ &#39;bar&#39; ],\n    which  : &#39;foo&#39;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Most people would be fine with splitting by <code class=\"language-text\">/</code> but if you wanted another character you can override this via:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Ext.define(&#39;Override.route.Route&#39;, {\n    override : &#39;Ext.route.Route&#39;,\n\n    config : {\n        types : {\n            &#39;...&#39; : {\n                split : &#39;-&#39;\n            }\n        }\n    }\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>This also shows there are 3 things you can use when defining your own type. The <code class=\"language-text\">...</code> is just a type defined as such:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">&#39;...&#39;: {\n    re: &#39;(.+)?&#39;,\n    split: &#39;/&#39;,\n    parse: function (values) {\n        var length, i, value;\n\n        if (values) {\n            length = values.length;\n\n            for (i = 0; i &lt; length; i++) {\n                value = parseFloat(values[i]);\n\n                if (!isNaN(value)) {\n                    values[i] = value;\n                }\n            }\n        } else if (Ext.isString(values)) {\n            // IE8 may have values as an empty string\n            // if there was no args that were matched\n            values = undefined;\n        }\n\n        return values;\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Simple to understand, the <code class=\"language-text\">re</code> is the string that will control what pattern will be matched, <code class=\"language-text\">split</code> will turn the value into an array (or undefined if no matches) and <code class=\"language-text\">parse</code> allows you to parse the value into something else.</p>\n<p>One type that could be useful and has come up a couple times in the last couple weeks is supporting query parameters in a hash. So you could use something like <code class=\"language-text\">#foo?bar&amp;baz=2</code> and the query string like part would be turned into a nested object. You coul duse this override to support this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">Ext.define(&#39;Override.route.Route&#39;, {\n    override : &#39;Ext.route.Route&#39;,\n\n    config : {\n        types : {\n            queryString : {\n                re    : &#39;(?:\\\\?(.+))?&#39;,\n                parse : function (params) {\n                    var name, value;\n\n                    if (params) {\n                        params = Ext.Object.fromQueryString(params);\n\n                        for (name in params) {\n                            value = params[name];\n\n                            if (value) {\n                                if (/^[0-9]+$/.test(value)) {\n                                    // let&#39;s turn this into a float\n                                    params[name] = parseFloat(value);\n                                }\n                            }\n                            // an empty string would be ?foo\n                            // which can be seen as truthy\n                            else if (Ext.isString(value)) {\n                                params[name] = true;\n                            }\n                        }\n                    }\n\n                    return params;\n                }\n            }\n        }\n    }\n});</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>You’d then defined your route as:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">routes : {\n    &#39;foo:{query:queryString}&#39;   : {\n        action : &#39;onFoo&#39;,\n        name   : &#39;foo&#39;\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So if you had the hash as <code class=\"language-text\">#foo?bar&amp;baz=2.1</code> then the params send to the <code class=\"language-text\">onFoo</code> method would be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">{\n    query : {\n        bar : true,\n        baz : 2.1\n    }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<h1>Summary</h1>\n<p>Once again, Sencha has listened to it’s community and along with what we learn as we use the router, the router is only getting better. More and more people are using in different applications and knowing how people use the router has been immensely helpful in crafting new features. Keep letting us know what you’d like. Open a forum thread and get my attention (Twitter is a great way, <a href=\"https://twitter.com/@LikelyMitch\">@LikelyMitch</a>) and I’d be more than happy to discuss it with you and give my honest personal opinion. :)</p>","fields":{"readingTime":{"text":"14 min read"},"slug":"/2017/08/21/6-6-router-improvements/"},"frontmatter":{"title":"6.6 Router Improvements","date":"August 21, 2017"}}},"pageContext":{"slug":"/2017/08/21/6-6-router-improvements/","previous":{"fields":{"slug":"/2017/04/12/package-loading/"},"frontmatter":{"title":"Package Loading on the Fly"}},"next":{"fields":{"slug":"/2017/09/22/next-chapter-in-2017/"},"frontmatter":{"title":"Next Chapter in 2017"}}}}}